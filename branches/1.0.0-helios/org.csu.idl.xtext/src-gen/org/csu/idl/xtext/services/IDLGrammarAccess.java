/*
* generated by Xtext
*/

package org.csu.idl.xtext.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class IDLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class SpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "specification");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTranslationUnitAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cIncludesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIncludesInclude_declParserRuleCall_1_0 = (RuleCall)cIncludesAssignment_1.eContents().get(0);
		private final Assignment cContainsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cContainsDefinitionParserRuleCall_2_0 = (RuleCall)cContainsAssignment_2.eContents().get(0);
		
		//specification returns IDL::TranslationUnit:
		//	{IDL::TranslationUnit} includes+=include_decl* contains+=definition*;
		public ParserRule getRule() { return rule; }

		//{IDL::TranslationUnit} includes+=include_decl* contains+=definition*
		public Group getGroup() { return cGroup; }

		//{IDL::TranslationUnit}
		public Action getTranslationUnitAction_0() { return cTranslationUnitAction_0; }

		//includes+=include_decl*
		public Assignment getIncludesAssignment_1() { return cIncludesAssignment_1; }

		//include_decl
		public RuleCall getIncludesInclude_declParserRuleCall_1_0() { return cIncludesInclude_declParserRuleCall_1_0; }

		//contains+=definition*
		public Assignment getContainsAssignment_2() { return cContainsAssignment_2; }

		//definition
		public RuleCall getContainsDefinitionParserRuleCall_2_0() { return cContainsDefinitionParserRuleCall_2_0; }
	}

	public class Include_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "include_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIncludeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportURIAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportURISTRINGTerminalRuleCall_1_0 = (RuleCall)cImportURIAssignment_1.eContents().get(0);
		
		//include_decl returns IDL::Include:
		//	"#include" importURI=STRING;
		public ParserRule getRule() { return rule; }

		//"#include" importURI=STRING
		public Group getGroup() { return cGroup; }

		//"#include"
		public Keyword getIncludeKeyword_0() { return cIncludeKeyword_0; }

		//importURI=STRING
		public Assignment getImportURIAssignment_1() { return cImportURIAssignment_1; }

		//STRING
		public RuleCall getImportURISTRINGTerminalRuleCall_1_0() { return cImportURISTRINGTerminalRuleCall_1_0; }
	}

	public class DefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "definition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cType_declParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cConst_declParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cExcept_declParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cInterface_declParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cInterface_fwdParserRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Group cGroup_5 = (Group)cAlternatives.eContents().get(5);
		private final RuleCall cModuleParserRuleCall_5_0 = (RuleCall)cGroup_5.eContents().get(0);
		private final Keyword cSemicolonKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		
		////|	value ';'	//value pertenece a corba 2.3
		////|	type_id_decl ';'
		////|	type_prefix_decl ';'
		////|	event ';'
		////|	component ';'
		////|	home_decl ';'
		//definition returns IDL::Contained:
		//	type_decl ";" | const_decl ";" | except_decl ";" | interface_decl ";" | interface_fwd ";" | module ";";
		public ParserRule getRule() { return rule; }

		//type_decl ";" | const_decl ";" | except_decl ";" | interface_decl ";" | interface_fwd ";" | module ";"
		public Alternatives getAlternatives() { return cAlternatives; }

		//type_decl ";"
		public Group getGroup_0() { return cGroup_0; }

		//type_decl
		public RuleCall getType_declParserRuleCall_0_0() { return cType_declParserRuleCall_0_0; }

		//";"
		public Keyword getSemicolonKeyword_0_1() { return cSemicolonKeyword_0_1; }

		//const_decl ";"
		public Group getGroup_1() { return cGroup_1; }

		//const_decl
		public RuleCall getConst_declParserRuleCall_1_0() { return cConst_declParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }

		//except_decl ";"
		public Group getGroup_2() { return cGroup_2; }

		//except_decl
		public RuleCall getExcept_declParserRuleCall_2_0() { return cExcept_declParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }

		//interface_decl ";"
		public Group getGroup_3() { return cGroup_3; }

		//interface_decl
		public RuleCall getInterface_declParserRuleCall_3_0() { return cInterface_declParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_3_1() { return cSemicolonKeyword_3_1; }

		//interface_fwd ";"
		public Group getGroup_4() { return cGroup_4; }

		//interface_fwd
		public RuleCall getInterface_fwdParserRuleCall_4_0() { return cInterface_fwdParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_4_1() { return cSemicolonKeyword_4_1; }

		//module ";"
		public Group getGroup_5() { return cGroup_5; }

		//module
		public RuleCall getModuleParserRuleCall_5_0() { return cModuleParserRuleCall_5_0; }

		//";"
		public Keyword getSemicolonKeyword_5_1() { return cSemicolonKeyword_5_1; }
	}

	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdentifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_0 = (RuleCall)cIdentifierAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Assignment cContainsAssignment_3_0 = (Assignment)cAlternatives_3.eContents().get(0);
		private final RuleCall cContainsDefinitionParserRuleCall_3_0_0 = (RuleCall)cContainsAssignment_3_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_1 = (Keyword)cAlternatives_3.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//module returns IDL::ModuleDef:
		//	"module" identifier=ID "{" (contains+=definition | ";")* "}";
		public ParserRule getRule() { return rule; }

		//"module" identifier=ID "{" (contains+=definition | ";")* "}"
		public Group getGroup() { return cGroup; }

		//"module"
		public Keyword getModuleKeyword_0() { return cModuleKeyword_0; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1() { return cIdentifierAssignment_1; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_0() { return cIdentifierIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//(contains+=definition | ";")*
		public Alternatives getAlternatives_3() { return cAlternatives_3; }

		//contains+=definition
		public Assignment getContainsAssignment_3_0() { return cContainsAssignment_3_0; }

		//definition
		public RuleCall getContainsDefinitionParserRuleCall_3_0_0() { return cContainsDefinitionParserRuleCall_3_0_0; }

		//";"
		public Keyword getSemicolonKeyword_3_1() { return cSemicolonKeyword_3_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class Interface_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "interface_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cIsAbstractAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final Keyword cIsAbstractAbstractKeyword_0_0_0 = (Keyword)cIsAbstractAssignment_0_0.eContents().get(0);
		private final Assignment cIsCustomAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final Keyword cIsCustomLocalKeyword_0_1_0 = (Keyword)cIsCustomAssignment_0_1.eContents().get(0);
		private final Keyword cInterfaceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIdentifierAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_2_0 = (RuleCall)cIdentifierAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cDerivesFromAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cDerivesFromInterfaceDefCrossReference_3_1_0 = (CrossReference)cDerivesFromAssignment_3_1.eContents().get(0);
		private final RuleCall cDerivesFromInterfaceDefIDTerminalRuleCall_3_1_0_1 = (RuleCall)cDerivesFromInterfaceDefCrossReference_3_1_0.eContents().get(1);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cDerivesFromAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final CrossReference cDerivesFromInterfaceDefCrossReference_3_2_1_0 = (CrossReference)cDerivesFromAssignment_3_2_1.eContents().get(0);
		private final RuleCall cDerivesFromInterfaceDefIDTerminalRuleCall_3_2_1_0_1 = (RuleCall)cDerivesFromInterfaceDefCrossReference_3_2_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_5 = (Alternatives)cGroup.eContents().get(5);
		private final Assignment cContainsAssignment_5_0 = (Assignment)cAlternatives_5.eContents().get(0);
		private final RuleCall cContainsExportParserRuleCall_5_0_0 = (RuleCall)cContainsAssignment_5_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_5_1 = (Keyword)cAlternatives_5.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//interface_decl returns IDL::InterfaceDef:
		//	(isAbstract?="abstract" | isCustom?="local")? "interface" identifier=ID (":" derivesFrom+=[IDL::InterfaceDef] (","
		//	derivesFrom+=[IDL::InterfaceDef])*)? "{" (contains+=export | ";")* "}";
		public ParserRule getRule() { return rule; }

		//(isAbstract?="abstract" | isCustom?="local")? "interface" identifier=ID (":" derivesFrom+=[IDL::InterfaceDef] (","
		//derivesFrom+=[IDL::InterfaceDef])*)? "{" (contains+=export | ";")* "}"
		public Group getGroup() { return cGroup; }

		//(isAbstract?="abstract" | isCustom?="local")?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//isAbstract?="abstract"
		public Assignment getIsAbstractAssignment_0_0() { return cIsAbstractAssignment_0_0; }

		//"abstract"
		public Keyword getIsAbstractAbstractKeyword_0_0_0() { return cIsAbstractAbstractKeyword_0_0_0; }

		//isCustom?="local"
		public Assignment getIsCustomAssignment_0_1() { return cIsCustomAssignment_0_1; }

		//"local"
		public Keyword getIsCustomLocalKeyword_0_1_0() { return cIsCustomLocalKeyword_0_1_0; }

		//"interface"
		public Keyword getInterfaceKeyword_1() { return cInterfaceKeyword_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_2() { return cIdentifierAssignment_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_2_0() { return cIdentifierIDTerminalRuleCall_2_0; }

		//(":" derivesFrom+=[IDL::InterfaceDef] ("," derivesFrom+=[IDL::InterfaceDef])*)?
		public Group getGroup_3() { return cGroup_3; }

		//":"
		public Keyword getColonKeyword_3_0() { return cColonKeyword_3_0; }

		//derivesFrom+=[IDL::InterfaceDef]
		public Assignment getDerivesFromAssignment_3_1() { return cDerivesFromAssignment_3_1; }

		//[IDL::InterfaceDef]
		public CrossReference getDerivesFromInterfaceDefCrossReference_3_1_0() { return cDerivesFromInterfaceDefCrossReference_3_1_0; }

		//ID
		public RuleCall getDerivesFromInterfaceDefIDTerminalRuleCall_3_1_0_1() { return cDerivesFromInterfaceDefIDTerminalRuleCall_3_1_0_1; }

		//("," derivesFrom+=[IDL::InterfaceDef])*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }

		//derivesFrom+=[IDL::InterfaceDef]
		public Assignment getDerivesFromAssignment_3_2_1() { return cDerivesFromAssignment_3_2_1; }

		//[IDL::InterfaceDef]
		public CrossReference getDerivesFromInterfaceDefCrossReference_3_2_1_0() { return cDerivesFromInterfaceDefCrossReference_3_2_1_0; }

		//ID
		public RuleCall getDerivesFromInterfaceDefIDTerminalRuleCall_3_2_1_0_1() { return cDerivesFromInterfaceDefIDTerminalRuleCall_3_2_1_0_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }

		//(contains+=export | ";")*
		public Alternatives getAlternatives_5() { return cAlternatives_5; }

		//contains+=export
		public Assignment getContainsAssignment_5_0() { return cContainsAssignment_5_0; }

		//export
		public RuleCall getContainsExportParserRuleCall_5_0_0() { return cContainsExportParserRuleCall_5_0_0; }

		//";"
		public Keyword getSemicolonKeyword_5_1() { return cSemicolonKeyword_5_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}

	public class Interface_fwdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "interface_fwd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cAbstractKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cLocalKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Keyword cInterfaceKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIdentifierAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_2_0 = (RuleCall)cIdentifierAssignment_2.eContents().get(0);
		
		//interface_fwd returns IDL::ForwardDef:
		//	("abstract" | "local")? "interface" identifier=ID;
		public ParserRule getRule() { return rule; }

		//("abstract" | "local")? "interface" identifier=ID
		public Group getGroup() { return cGroup; }

		//("abstract" | "local")?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"abstract"
		public Keyword getAbstractKeyword_0_0() { return cAbstractKeyword_0_0; }

		//"local"
		public Keyword getLocalKeyword_0_1() { return cLocalKeyword_0_1; }

		//"interface"
		public Keyword getInterfaceKeyword_1() { return cInterfaceKeyword_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_2() { return cIdentifierAssignment_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_2_0() { return cIdentifierIDTerminalRuleCall_2_0; }
	}

	public class ExportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "export");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cType_declParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cConst_declParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cExcept_declParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final RuleCall cAttr_declParserRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final RuleCall cOp_declParserRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		
		////	|	type_id_decl ';'
		////	|	type_prefix_decl ';'
		//export returns IDL::Contained:
		//	type_decl ";" | const_decl ";" | except_decl ";" | attr_decl ";" | op_decl ";";
		public ParserRule getRule() { return rule; }

		//type_decl ";" | const_decl ";" | except_decl ";" | attr_decl ";" | op_decl ";"
		public Alternatives getAlternatives() { return cAlternatives; }

		//type_decl ";"
		public Group getGroup_0() { return cGroup_0; }

		//type_decl
		public RuleCall getType_declParserRuleCall_0_0() { return cType_declParserRuleCall_0_0; }

		//";"
		public Keyword getSemicolonKeyword_0_1() { return cSemicolonKeyword_0_1; }

		//const_decl ";"
		public Group getGroup_1() { return cGroup_1; }

		//const_decl
		public RuleCall getConst_declParserRuleCall_1_0() { return cConst_declParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }

		//except_decl ";"
		public Group getGroup_2() { return cGroup_2; }

		//except_decl
		public RuleCall getExcept_declParserRuleCall_2_0() { return cExcept_declParserRuleCall_2_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }

		//attr_decl ";"
		public Group getGroup_3() { return cGroup_3; }

		//attr_decl
		public RuleCall getAttr_declParserRuleCall_3_0() { return cAttr_declParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_3_1() { return cSemicolonKeyword_3_1; }

		//op_decl ";"
		public Group getGroup_4() { return cGroup_4; }

		//op_decl
		public RuleCall getOp_declParserRuleCall_4_0() { return cOp_declParserRuleCall_4_0; }

		//";"
		public Keyword getSemicolonKeyword_4_1() { return cSemicolonKeyword_4_1; }
	}

	public class Op_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "op_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIsOnewayAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cIsOnewayOnewayKeyword_0_0 = (Keyword)cIsOnewayAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cContainedTypeAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cContainedTypeOp_type_specParserRuleCall_1_0_0 = (RuleCall)cContainedTypeAssignment_1_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_1_1_0 = (CrossReference)cSharedTypeAssignment_1_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_1_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_1_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_2_0 = (RuleCall)cIdentifierAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cParametersAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cParametersParam_declParserRuleCall_4_0_0 = (RuleCall)cParametersAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cParametersAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cParametersParam_declParserRuleCall_4_1_1_0 = (RuleCall)cParametersAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cRaisesKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cCanRaiseAssignment_6_2 = (Assignment)cGroup_6.eContents().get(2);
		private final CrossReference cCanRaiseExceptionDefCrossReference_6_2_0 = (CrossReference)cCanRaiseAssignment_6_2.eContents().get(0);
		private final RuleCall cCanRaiseExceptionDefIDTerminalRuleCall_6_2_0_1 = (RuleCall)cCanRaiseExceptionDefCrossReference_6_2_0.eContents().get(1);
		private final Group cGroup_6_3 = (Group)cGroup_6.eContents().get(3);
		private final Keyword cCommaKeyword_6_3_0 = (Keyword)cGroup_6_3.eContents().get(0);
		private final Assignment cCanRaiseAssignment_6_3_1 = (Assignment)cGroup_6_3.eContents().get(1);
		private final CrossReference cCanRaiseExceptionDefCrossReference_6_3_1_0 = (CrossReference)cCanRaiseAssignment_6_3_1.eContents().get(0);
		private final RuleCall cCanRaiseExceptionDefIDTerminalRuleCall_6_3_1_0_1 = (RuleCall)cCanRaiseExceptionDefCrossReference_6_3_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_6_4 = (Keyword)cGroup_6.eContents().get(4);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cContextKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final Assignment cContextsAssignment_7_2 = (Assignment)cGroup_7.eContents().get(2);
		private final RuleCall cContextsSTRINGTerminalRuleCall_7_2_0 = (RuleCall)cContextsAssignment_7_2.eContents().get(0);
		private final Group cGroup_7_3 = (Group)cGroup_7.eContents().get(3);
		private final Keyword cCommaKeyword_7_3_0 = (Keyword)cGroup_7_3.eContents().get(0);
		private final Assignment cContextsAssignment_7_3_1 = (Assignment)cGroup_7_3.eContents().get(1);
		private final RuleCall cContextsSTRINGTerminalRuleCall_7_3_1_0 = (RuleCall)cContextsAssignment_7_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7_4 = (Keyword)cGroup_7.eContents().get(4);
		
		//op_decl returns IDL::OperationDef:
		//	isOneway?="oneway"? (containedType=op_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID "("
		//	(parameters+=param_decl ("," parameters+=param_decl)*)? ")" ("raises" "(" canRaise+=[IDL::ExceptionDef] (","
		//	canRaise+=[IDL::ExceptionDef])* ")")? ("context" "(" contexts+=STRING ("," contexts+=STRING)* ")")?;
		public ParserRule getRule() { return rule; }

		//isOneway?="oneway"? (containedType=op_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID "("
		//(parameters+=param_decl ("," parameters+=param_decl)*)? ")" ("raises" "(" canRaise+=[IDL::ExceptionDef] (","
		//canRaise+=[IDL::ExceptionDef])* ")")? ("context" "(" contexts+=STRING ("," contexts+=STRING)* ")")?
		public Group getGroup() { return cGroup; }

		//isOneway?="oneway"?
		public Assignment getIsOnewayAssignment_0() { return cIsOnewayAssignment_0; }

		//"oneway"
		public Keyword getIsOnewayOnewayKeyword_0_0() { return cIsOnewayOnewayKeyword_0_0; }

		//containedType=op_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//containedType=op_type_spec
		public Assignment getContainedTypeAssignment_1_0() { return cContainedTypeAssignment_1_0; }

		//op_type_spec
		public RuleCall getContainedTypeOp_type_specParserRuleCall_1_0_0() { return cContainedTypeOp_type_specParserRuleCall_1_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_1_1() { return cSharedTypeAssignment_1_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_1_1_0() { return cSharedTypeTypedefDefCrossReference_1_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_1_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_1_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_2() { return cIdentifierAssignment_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_2_0() { return cIdentifierIDTerminalRuleCall_2_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//(parameters+=param_decl ("," parameters+=param_decl)*)?
		public Group getGroup_4() { return cGroup_4; }

		//parameters+=param_decl
		public Assignment getParametersAssignment_4_0() { return cParametersAssignment_4_0; }

		//param_decl
		public RuleCall getParametersParam_declParserRuleCall_4_0_0() { return cParametersParam_declParserRuleCall_4_0_0; }

		//("," parameters+=param_decl)*
		public Group getGroup_4_1() { return cGroup_4_1; }

		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }

		//parameters+=param_decl
		public Assignment getParametersAssignment_4_1_1() { return cParametersAssignment_4_1_1; }

		//param_decl
		public RuleCall getParametersParam_declParserRuleCall_4_1_1_0() { return cParametersParam_declParserRuleCall_4_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//("raises" "(" canRaise+=[IDL::ExceptionDef] ("," canRaise+=[IDL::ExceptionDef])* ")")?
		public Group getGroup_6() { return cGroup_6; }

		//"raises"
		public Keyword getRaisesKeyword_6_0() { return cRaisesKeyword_6_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_6_1() { return cLeftParenthesisKeyword_6_1; }

		//canRaise+=[IDL::ExceptionDef]
		public Assignment getCanRaiseAssignment_6_2() { return cCanRaiseAssignment_6_2; }

		//[IDL::ExceptionDef]
		public CrossReference getCanRaiseExceptionDefCrossReference_6_2_0() { return cCanRaiseExceptionDefCrossReference_6_2_0; }

		//ID
		public RuleCall getCanRaiseExceptionDefIDTerminalRuleCall_6_2_0_1() { return cCanRaiseExceptionDefIDTerminalRuleCall_6_2_0_1; }

		//("," canRaise+=[IDL::ExceptionDef])*
		public Group getGroup_6_3() { return cGroup_6_3; }

		//","
		public Keyword getCommaKeyword_6_3_0() { return cCommaKeyword_6_3_0; }

		//canRaise+=[IDL::ExceptionDef]
		public Assignment getCanRaiseAssignment_6_3_1() { return cCanRaiseAssignment_6_3_1; }

		//[IDL::ExceptionDef]
		public CrossReference getCanRaiseExceptionDefCrossReference_6_3_1_0() { return cCanRaiseExceptionDefCrossReference_6_3_1_0; }

		//ID
		public RuleCall getCanRaiseExceptionDefIDTerminalRuleCall_6_3_1_0_1() { return cCanRaiseExceptionDefIDTerminalRuleCall_6_3_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_6_4() { return cRightParenthesisKeyword_6_4; }

		//("context" "(" contexts+=STRING ("," contexts+=STRING)* ")")?
		public Group getGroup_7() { return cGroup_7; }

		//"context"
		public Keyword getContextKeyword_7_0() { return cContextKeyword_7_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_7_1() { return cLeftParenthesisKeyword_7_1; }

		//contexts+=STRING
		public Assignment getContextsAssignment_7_2() { return cContextsAssignment_7_2; }

		//STRING
		public RuleCall getContextsSTRINGTerminalRuleCall_7_2_0() { return cContextsSTRINGTerminalRuleCall_7_2_0; }

		//("," contexts+=STRING)*
		public Group getGroup_7_3() { return cGroup_7_3; }

		//","
		public Keyword getCommaKeyword_7_3_0() { return cCommaKeyword_7_3_0; }

		//contexts+=STRING
		public Assignment getContextsAssignment_7_3_1() { return cContextsAssignment_7_3_1; }

		//STRING
		public RuleCall getContextsSTRINGTerminalRuleCall_7_3_1_0() { return cContextsSTRINGTerminalRuleCall_7_3_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7_4() { return cRightParenthesisKeyword_7_4; }
	}

	public class Op_type_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "op_type_spec");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBase_type_specParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPrimitiveDefAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cKindAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cKindVoid_typeEnumRuleCall_1_1_0 = (RuleCall)cKindAssignment_1_1.eContents().get(0);
		
		//op_type_spec returns IDL::IDLType:
		//	base_type_spec | {IDL::PrimitiveDef} kind=void_type;
		public ParserRule getRule() { return rule; }

		//base_type_spec | {IDL::PrimitiveDef} kind=void_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//base_type_spec
		public RuleCall getBase_type_specParserRuleCall_0() { return cBase_type_specParserRuleCall_0; }

		//{IDL::PrimitiveDef} kind=void_type
		public Group getGroup_1() { return cGroup_1; }

		//{IDL::PrimitiveDef}
		public Action getPrimitiveDefAction_1_0() { return cPrimitiveDefAction_1_0; }

		//kind=void_type
		public Assignment getKindAssignment_1_1() { return cKindAssignment_1_1; }

		//void_type
		public RuleCall getKindVoid_typeEnumRuleCall_1_1_0() { return cKindVoid_typeEnumRuleCall_1_1_0; }
	}

	public class Param_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "param_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDirectionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDirectionParam_attributeEnumRuleCall_0_0 = (RuleCall)cDirectionAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cContainedTypeAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cContainedTypeBase_type_specParserRuleCall_1_0_0 = (RuleCall)cContainedTypeAssignment_1_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_1_1_0 = (CrossReference)cSharedTypeAssignment_1_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_1_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_1_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_2_0 = (RuleCall)cIdentifierAssignment_2.eContents().get(0);
		
		//param_decl returns IDL::ParameterDef:
		//	direction=param_attribute (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID;
		public ParserRule getRule() { return rule; }

		//direction=param_attribute (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID
		public Group getGroup() { return cGroup; }

		//direction=param_attribute
		public Assignment getDirectionAssignment_0() { return cDirectionAssignment_0; }

		//param_attribute
		public RuleCall getDirectionParam_attributeEnumRuleCall_0_0() { return cDirectionParam_attributeEnumRuleCall_0_0; }

		//containedType=base_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//containedType=base_type_spec
		public Assignment getContainedTypeAssignment_1_0() { return cContainedTypeAssignment_1_0; }

		//base_type_spec
		public RuleCall getContainedTypeBase_type_specParserRuleCall_1_0_0() { return cContainedTypeBase_type_specParserRuleCall_1_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_1_1() { return cSharedTypeAssignment_1_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_1_1_0() { return cSharedTypeTypedefDefCrossReference_1_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_1_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_1_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_2() { return cIdentifierAssignment_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_2_0() { return cIdentifierIDTerminalRuleCall_2_0; }
	}

	public class Attr_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "attr_decl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cReadonly_attr_specParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAttr_specParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//attr_decl returns IDL::AttributeDef:
		//	readonly_attr_spec | attr_spec;
		public ParserRule getRule() { return rule; }

		//readonly_attr_spec | attr_spec
		public Alternatives getAlternatives() { return cAlternatives; }

		//readonly_attr_spec
		public RuleCall getReadonly_attr_specParserRuleCall_0() { return cReadonly_attr_specParserRuleCall_0; }

		//attr_spec
		public RuleCall getAttr_specParserRuleCall_1() { return cAttr_specParserRuleCall_1; }
	}

	public class Readonly_attr_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "readonly_attr_spec");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cIsReadonlyAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cIsReadonlyReadonlyKeyword_0_0_0 = (Keyword)cIsReadonlyAssignment_0_0.eContents().get(0);
		private final Keyword cAttributeKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Alternatives cAlternatives_0_2 = (Alternatives)cGroup_0.eContents().get(2);
		private final Assignment cContainedTypeAssignment_0_2_0 = (Assignment)cAlternatives_0_2.eContents().get(0);
		private final RuleCall cContainedTypeBase_type_specParserRuleCall_0_2_0_0 = (RuleCall)cContainedTypeAssignment_0_2_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_0_2_1 = (Assignment)cAlternatives_0_2.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_0_2_1_0 = (CrossReference)cSharedTypeAssignment_0_2_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_0_2_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_0_2_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_0_3 = (Assignment)cGroup_0.eContents().get(3);
		private final RuleCall cIdentifierIDTerminalRuleCall_0_3_0 = (RuleCall)cIdentifierAssignment_0_3.eContents().get(0);
		private final Keyword cRaisesKeyword_0_4 = (Keyword)cGroup_0.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Assignment cGetRaisesAssignment_0_6 = (Assignment)cGroup_0.eContents().get(6);
		private final CrossReference cGetRaisesExceptionDefCrossReference_0_6_0 = (CrossReference)cGetRaisesAssignment_0_6.eContents().get(0);
		private final RuleCall cGetRaisesExceptionDefIDTerminalRuleCall_0_6_0_1 = (RuleCall)cGetRaisesExceptionDefCrossReference_0_6_0.eContents().get(1);
		private final Group cGroup_0_7 = (Group)cGroup_0.eContents().get(7);
		private final Keyword cCommaKeyword_0_7_0 = (Keyword)cGroup_0_7.eContents().get(0);
		private final Assignment cGetRaisesAssignment_0_7_1 = (Assignment)cGroup_0_7.eContents().get(1);
		private final CrossReference cGetRaisesExceptionDefCrossReference_0_7_1_0 = (CrossReference)cGetRaisesAssignment_0_7_1.eContents().get(0);
		private final RuleCall cGetRaisesExceptionDefIDTerminalRuleCall_0_7_1_0_1 = (RuleCall)cGetRaisesExceptionDefCrossReference_0_7_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_8 = (Keyword)cGroup_0.eContents().get(8);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cIsReadonlyAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cIsReadonlyReadonlyKeyword_1_0_0 = (Keyword)cIsReadonlyAssignment_1_0.eContents().get(0);
		private final Keyword cAttributeKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Alternatives cAlternatives_1_2 = (Alternatives)cGroup_1.eContents().get(2);
		private final Assignment cContainedTypeAssignment_1_2_0 = (Assignment)cAlternatives_1_2.eContents().get(0);
		private final RuleCall cContainedTypeBase_type_specParserRuleCall_1_2_0_0 = (RuleCall)cContainedTypeAssignment_1_2_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_1_2_1 = (Assignment)cAlternatives_1_2.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_1_2_1_0 = (CrossReference)cSharedTypeAssignment_1_2_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_1_2_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_1_2_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_3_0 = (RuleCall)cIdentifierAssignment_1_3.eContents().get(0);
		
		//readonly_attr_spec returns IDL::AttributeDef:
		//	isReadonly?="readonly" "attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID
		//	"raises" "(" getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" | isReadonly?="readonly"
		//	"attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID;
		public ParserRule getRule() { return rule; }

		//isReadonly?="readonly" "attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID "raises"
		//"(" getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" | isReadonly?="readonly" "attribute"
		//(containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//isReadonly?="readonly" "attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID "raises"
		//"(" getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")"
		public Group getGroup_0() { return cGroup_0; }

		//isReadonly?="readonly"
		public Assignment getIsReadonlyAssignment_0_0() { return cIsReadonlyAssignment_0_0; }

		//"readonly"
		public Keyword getIsReadonlyReadonlyKeyword_0_0_0() { return cIsReadonlyReadonlyKeyword_0_0_0; }

		//"attribute"
		public Keyword getAttributeKeyword_0_1() { return cAttributeKeyword_0_1; }

		//containedType=base_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_0_2() { return cAlternatives_0_2; }

		//containedType=base_type_spec
		public Assignment getContainedTypeAssignment_0_2_0() { return cContainedTypeAssignment_0_2_0; }

		//base_type_spec
		public RuleCall getContainedTypeBase_type_specParserRuleCall_0_2_0_0() { return cContainedTypeBase_type_specParserRuleCall_0_2_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_0_2_1() { return cSharedTypeAssignment_0_2_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_0_2_1_0() { return cSharedTypeTypedefDefCrossReference_0_2_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_0_2_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_0_2_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_0_3() { return cIdentifierAssignment_0_3; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_0_3_0() { return cIdentifierIDTerminalRuleCall_0_3_0; }

		//"raises"
		public Keyword getRaisesKeyword_0_4() { return cRaisesKeyword_0_4; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_5() { return cLeftParenthesisKeyword_0_5; }

		//getRaises+=[IDL::ExceptionDef]
		public Assignment getGetRaisesAssignment_0_6() { return cGetRaisesAssignment_0_6; }

		//[IDL::ExceptionDef]
		public CrossReference getGetRaisesExceptionDefCrossReference_0_6_0() { return cGetRaisesExceptionDefCrossReference_0_6_0; }

		//ID
		public RuleCall getGetRaisesExceptionDefIDTerminalRuleCall_0_6_0_1() { return cGetRaisesExceptionDefIDTerminalRuleCall_0_6_0_1; }

		//("," getRaises+=[IDL::ExceptionDef])*
		public Group getGroup_0_7() { return cGroup_0_7; }

		//","
		public Keyword getCommaKeyword_0_7_0() { return cCommaKeyword_0_7_0; }

		//getRaises+=[IDL::ExceptionDef]
		public Assignment getGetRaisesAssignment_0_7_1() { return cGetRaisesAssignment_0_7_1; }

		//[IDL::ExceptionDef]
		public CrossReference getGetRaisesExceptionDefCrossReference_0_7_1_0() { return cGetRaisesExceptionDefCrossReference_0_7_1_0; }

		//ID
		public RuleCall getGetRaisesExceptionDefIDTerminalRuleCall_0_7_1_0_1() { return cGetRaisesExceptionDefIDTerminalRuleCall_0_7_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_8() { return cRightParenthesisKeyword_0_8; }

		//isReadonly?="readonly" "attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID
		public Group getGroup_1() { return cGroup_1; }

		//isReadonly?="readonly"
		public Assignment getIsReadonlyAssignment_1_0() { return cIsReadonlyAssignment_1_0; }

		//"readonly"
		public Keyword getIsReadonlyReadonlyKeyword_1_0_0() { return cIsReadonlyReadonlyKeyword_1_0_0; }

		//"attribute"
		public Keyword getAttributeKeyword_1_1() { return cAttributeKeyword_1_1; }

		//containedType=base_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_1_2() { return cAlternatives_1_2; }

		//containedType=base_type_spec
		public Assignment getContainedTypeAssignment_1_2_0() { return cContainedTypeAssignment_1_2_0; }

		//base_type_spec
		public RuleCall getContainedTypeBase_type_specParserRuleCall_1_2_0_0() { return cContainedTypeBase_type_specParserRuleCall_1_2_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_1_2_1() { return cSharedTypeAssignment_1_2_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_1_2_1_0() { return cSharedTypeTypedefDefCrossReference_1_2_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_1_2_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_1_2_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1_3() { return cIdentifierAssignment_1_3; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_3_0() { return cIdentifierIDTerminalRuleCall_1_3_0; }
	}

	public class Attr_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "attr_spec");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cAttributeKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Alternatives cAlternatives_0_1 = (Alternatives)cGroup_0.eContents().get(1);
		private final Assignment cContainedTypeAssignment_0_1_0 = (Assignment)cAlternatives_0_1.eContents().get(0);
		private final RuleCall cContainedTypeBase_type_specParserRuleCall_0_1_0_0 = (RuleCall)cContainedTypeAssignment_0_1_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_0_1_1 = (Assignment)cAlternatives_0_1.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_0_1_1_0 = (CrossReference)cSharedTypeAssignment_0_1_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_0_1_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_0_1_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_0_2_0 = (RuleCall)cIdentifierAssignment_0_2.eContents().get(0);
		private final Alternatives cAlternatives_0_3 = (Alternatives)cGroup_0.eContents().get(3);
		private final Group cGroup_0_3_0 = (Group)cAlternatives_0_3.eContents().get(0);
		private final Keyword cGetraisesKeyword_0_3_0_0 = (Keyword)cGroup_0_3_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_3_0_1 = (Keyword)cGroup_0_3_0.eContents().get(1);
		private final Assignment cGetRaisesAssignment_0_3_0_2 = (Assignment)cGroup_0_3_0.eContents().get(2);
		private final CrossReference cGetRaisesExceptionDefCrossReference_0_3_0_2_0 = (CrossReference)cGetRaisesAssignment_0_3_0_2.eContents().get(0);
		private final RuleCall cGetRaisesExceptionDefIDTerminalRuleCall_0_3_0_2_0_1 = (RuleCall)cGetRaisesExceptionDefCrossReference_0_3_0_2_0.eContents().get(1);
		private final Group cGroup_0_3_0_3 = (Group)cGroup_0_3_0.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0_3_0 = (Keyword)cGroup_0_3_0_3.eContents().get(0);
		private final Assignment cGetRaisesAssignment_0_3_0_3_1 = (Assignment)cGroup_0_3_0_3.eContents().get(1);
		private final CrossReference cGetRaisesExceptionDefCrossReference_0_3_0_3_1_0 = (CrossReference)cGetRaisesAssignment_0_3_0_3_1.eContents().get(0);
		private final RuleCall cGetRaisesExceptionDefIDTerminalRuleCall_0_3_0_3_1_0_1 = (RuleCall)cGetRaisesExceptionDefCrossReference_0_3_0_3_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_3_0_4 = (Keyword)cGroup_0_3_0.eContents().get(4);
		private final Group cGroup_0_3_0_5 = (Group)cGroup_0_3_0.eContents().get(5);
		private final Keyword cSetraisesKeyword_0_3_0_5_0 = (Keyword)cGroup_0_3_0_5.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_3_0_5_1 = (Keyword)cGroup_0_3_0_5.eContents().get(1);
		private final Assignment cSetRaisesAssignment_0_3_0_5_2 = (Assignment)cGroup_0_3_0_5.eContents().get(2);
		private final CrossReference cSetRaisesExceptionDefCrossReference_0_3_0_5_2_0 = (CrossReference)cSetRaisesAssignment_0_3_0_5_2.eContents().get(0);
		private final RuleCall cSetRaisesExceptionDefIDTerminalRuleCall_0_3_0_5_2_0_1 = (RuleCall)cSetRaisesExceptionDefCrossReference_0_3_0_5_2_0.eContents().get(1);
		private final Group cGroup_0_3_0_5_3 = (Group)cGroup_0_3_0_5.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_0_5_3_0 = (Keyword)cGroup_0_3_0_5_3.eContents().get(0);
		private final Assignment cSetRaisesAssignment_0_3_0_5_3_1 = (Assignment)cGroup_0_3_0_5_3.eContents().get(1);
		private final CrossReference cSetRaisesExceptionDefCrossReference_0_3_0_5_3_1_0 = (CrossReference)cSetRaisesAssignment_0_3_0_5_3_1.eContents().get(0);
		private final RuleCall cSetRaisesExceptionDefIDTerminalRuleCall_0_3_0_5_3_1_0_1 = (RuleCall)cSetRaisesExceptionDefCrossReference_0_3_0_5_3_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_3_0_5_4 = (Keyword)cGroup_0_3_0_5.eContents().get(4);
		private final Group cGroup_0_3_1 = (Group)cAlternatives_0_3.eContents().get(1);
		private final Keyword cSetraisesKeyword_0_3_1_0 = (Keyword)cGroup_0_3_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_3_1_1 = (Keyword)cGroup_0_3_1.eContents().get(1);
		private final Assignment cSetRaisesAssignment_0_3_1_2 = (Assignment)cGroup_0_3_1.eContents().get(2);
		private final CrossReference cSetRaisesExceptionDefCrossReference_0_3_1_2_0 = (CrossReference)cSetRaisesAssignment_0_3_1_2.eContents().get(0);
		private final RuleCall cSetRaisesExceptionDefIDTerminalRuleCall_0_3_1_2_0_1 = (RuleCall)cSetRaisesExceptionDefCrossReference_0_3_1_2_0.eContents().get(1);
		private final Group cGroup_0_3_1_3 = (Group)cGroup_0_3_1.eContents().get(3);
		private final Keyword cCommaKeyword_0_3_1_3_0 = (Keyword)cGroup_0_3_1_3.eContents().get(0);
		private final Assignment cSetRaisesAssignment_0_3_1_3_1 = (Assignment)cGroup_0_3_1_3.eContents().get(1);
		private final CrossReference cSetRaisesExceptionDefCrossReference_0_3_1_3_1_0 = (CrossReference)cSetRaisesAssignment_0_3_1_3_1.eContents().get(0);
		private final RuleCall cSetRaisesExceptionDefIDTerminalRuleCall_0_3_1_3_1_0_1 = (RuleCall)cSetRaisesExceptionDefCrossReference_0_3_1_3_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_3_1_4 = (Keyword)cGroup_0_3_1.eContents().get(4);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cAttributeKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cContainedTypeAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cContainedTypeBase_type_specParserRuleCall_1_1_0_0 = (RuleCall)cContainedTypeAssignment_1_1_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_1_1_1_0 = (CrossReference)cSharedTypeAssignment_1_1_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_1_1_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_2_0 = (RuleCall)cIdentifierAssignment_1_2.eContents().get(0);
		
		//attr_spec returns IDL::AttributeDef:
		//	"attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID ("getraises" "("
		//	getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" ("setraises" "("
		//	setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")")? | "setraises" "("
		//	setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")") | "attribute" (containedType=base_type_spec
		//	| sharedType=[IDL::TypedefDef]) identifier=ID;
		public ParserRule getRule() { return rule; }

		//"attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID ("getraises" "("
		//getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" ("setraises" "("
		//setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")")? | "setraises" "("
		//setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")") | "attribute" (containedType=base_type_spec |
		//sharedType=[IDL::TypedefDef]) identifier=ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//"attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID ("getraises" "("
		//getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" ("setraises" "("
		//setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")")? | "setraises" "("
		//setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")")
		public Group getGroup_0() { return cGroup_0; }

		//"attribute"
		public Keyword getAttributeKeyword_0_0() { return cAttributeKeyword_0_0; }

		//containedType=base_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_0_1() { return cAlternatives_0_1; }

		//containedType=base_type_spec
		public Assignment getContainedTypeAssignment_0_1_0() { return cContainedTypeAssignment_0_1_0; }

		//base_type_spec
		public RuleCall getContainedTypeBase_type_specParserRuleCall_0_1_0_0() { return cContainedTypeBase_type_specParserRuleCall_0_1_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_0_1_1() { return cSharedTypeAssignment_0_1_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_0_1_1_0() { return cSharedTypeTypedefDefCrossReference_0_1_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_0_1_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_0_1_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_0_2() { return cIdentifierAssignment_0_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_0_2_0() { return cIdentifierIDTerminalRuleCall_0_2_0; }

		//"getraises" "(" getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" ("setraises" "("
		//setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")")? | "setraises" "("
		//setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")"
		public Alternatives getAlternatives_0_3() { return cAlternatives_0_3; }

		//"getraises" "(" getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" ("setraises" "("
		//setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")")?
		public Group getGroup_0_3_0() { return cGroup_0_3_0; }

		//"getraises"
		public Keyword getGetraisesKeyword_0_3_0_0() { return cGetraisesKeyword_0_3_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_3_0_1() { return cLeftParenthesisKeyword_0_3_0_1; }

		//getRaises+=[IDL::ExceptionDef]
		public Assignment getGetRaisesAssignment_0_3_0_2() { return cGetRaisesAssignment_0_3_0_2; }

		//[IDL::ExceptionDef]
		public CrossReference getGetRaisesExceptionDefCrossReference_0_3_0_2_0() { return cGetRaisesExceptionDefCrossReference_0_3_0_2_0; }

		//ID
		public RuleCall getGetRaisesExceptionDefIDTerminalRuleCall_0_3_0_2_0_1() { return cGetRaisesExceptionDefIDTerminalRuleCall_0_3_0_2_0_1; }

		//("," getRaises+=[IDL::ExceptionDef])*
		public Group getGroup_0_3_0_3() { return cGroup_0_3_0_3; }

		//","
		public Keyword getCommaKeyword_0_3_0_3_0() { return cCommaKeyword_0_3_0_3_0; }

		//getRaises+=[IDL::ExceptionDef]
		public Assignment getGetRaisesAssignment_0_3_0_3_1() { return cGetRaisesAssignment_0_3_0_3_1; }

		//[IDL::ExceptionDef]
		public CrossReference getGetRaisesExceptionDefCrossReference_0_3_0_3_1_0() { return cGetRaisesExceptionDefCrossReference_0_3_0_3_1_0; }

		//ID
		public RuleCall getGetRaisesExceptionDefIDTerminalRuleCall_0_3_0_3_1_0_1() { return cGetRaisesExceptionDefIDTerminalRuleCall_0_3_0_3_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_3_0_4() { return cRightParenthesisKeyword_0_3_0_4; }

		//("setraises" "(" setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")")?
		public Group getGroup_0_3_0_5() { return cGroup_0_3_0_5; }

		//"setraises"
		public Keyword getSetraisesKeyword_0_3_0_5_0() { return cSetraisesKeyword_0_3_0_5_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_3_0_5_1() { return cLeftParenthesisKeyword_0_3_0_5_1; }

		//setRaises+=[IDL::ExceptionDef]
		public Assignment getSetRaisesAssignment_0_3_0_5_2() { return cSetRaisesAssignment_0_3_0_5_2; }

		//[IDL::ExceptionDef]
		public CrossReference getSetRaisesExceptionDefCrossReference_0_3_0_5_2_0() { return cSetRaisesExceptionDefCrossReference_0_3_0_5_2_0; }

		//ID
		public RuleCall getSetRaisesExceptionDefIDTerminalRuleCall_0_3_0_5_2_0_1() { return cSetRaisesExceptionDefIDTerminalRuleCall_0_3_0_5_2_0_1; }

		//("," setRaises+=[IDL::ExceptionDef])*
		public Group getGroup_0_3_0_5_3() { return cGroup_0_3_0_5_3; }

		//","
		public Keyword getCommaKeyword_0_3_0_5_3_0() { return cCommaKeyword_0_3_0_5_3_0; }

		//setRaises+=[IDL::ExceptionDef]
		public Assignment getSetRaisesAssignment_0_3_0_5_3_1() { return cSetRaisesAssignment_0_3_0_5_3_1; }

		//[IDL::ExceptionDef]
		public CrossReference getSetRaisesExceptionDefCrossReference_0_3_0_5_3_1_0() { return cSetRaisesExceptionDefCrossReference_0_3_0_5_3_1_0; }

		//ID
		public RuleCall getSetRaisesExceptionDefIDTerminalRuleCall_0_3_0_5_3_1_0_1() { return cSetRaisesExceptionDefIDTerminalRuleCall_0_3_0_5_3_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_3_0_5_4() { return cRightParenthesisKeyword_0_3_0_5_4; }

		//"setraises" "(" setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")"
		public Group getGroup_0_3_1() { return cGroup_0_3_1; }

		//"setraises"
		public Keyword getSetraisesKeyword_0_3_1_0() { return cSetraisesKeyword_0_3_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_3_1_1() { return cLeftParenthesisKeyword_0_3_1_1; }

		//setRaises+=[IDL::ExceptionDef]
		public Assignment getSetRaisesAssignment_0_3_1_2() { return cSetRaisesAssignment_0_3_1_2; }

		//[IDL::ExceptionDef]
		public CrossReference getSetRaisesExceptionDefCrossReference_0_3_1_2_0() { return cSetRaisesExceptionDefCrossReference_0_3_1_2_0; }

		//ID
		public RuleCall getSetRaisesExceptionDefIDTerminalRuleCall_0_3_1_2_0_1() { return cSetRaisesExceptionDefIDTerminalRuleCall_0_3_1_2_0_1; }

		//("," setRaises+=[IDL::ExceptionDef])*
		public Group getGroup_0_3_1_3() { return cGroup_0_3_1_3; }

		//","
		public Keyword getCommaKeyword_0_3_1_3_0() { return cCommaKeyword_0_3_1_3_0; }

		//setRaises+=[IDL::ExceptionDef]
		public Assignment getSetRaisesAssignment_0_3_1_3_1() { return cSetRaisesAssignment_0_3_1_3_1; }

		//[IDL::ExceptionDef]
		public CrossReference getSetRaisesExceptionDefCrossReference_0_3_1_3_1_0() { return cSetRaisesExceptionDefCrossReference_0_3_1_3_1_0; }

		//ID
		public RuleCall getSetRaisesExceptionDefIDTerminalRuleCall_0_3_1_3_1_0_1() { return cSetRaisesExceptionDefIDTerminalRuleCall_0_3_1_3_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_3_1_4() { return cRightParenthesisKeyword_0_3_1_4; }

		//"attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID
		public Group getGroup_1() { return cGroup_1; }

		//"attribute"
		public Keyword getAttributeKeyword_1_0() { return cAttributeKeyword_1_0; }

		//containedType=base_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//containedType=base_type_spec
		public Assignment getContainedTypeAssignment_1_1_0() { return cContainedTypeAssignment_1_1_0; }

		//base_type_spec
		public RuleCall getContainedTypeBase_type_specParserRuleCall_1_1_0_0() { return cContainedTypeBase_type_specParserRuleCall_1_1_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_1_1_1() { return cSharedTypeAssignment_1_1_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_1_1_1_0() { return cSharedTypeTypedefDefCrossReference_1_1_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1_2() { return cIdentifierAssignment_1_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_2_0() { return cIdentifierIDTerminalRuleCall_1_2_0; }
	}

	public class Except_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "except_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExceptionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdentifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_0 = (RuleCall)cIdentifierAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMembersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMembersMemberParserRuleCall_3_0 = (RuleCall)cMembersAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//except_decl returns IDL::ExceptionDef:
		//	"exception" identifier=ID "{" members+=member* "}";
		public ParserRule getRule() { return rule; }

		//"exception" identifier=ID "{" members+=member* "}"
		public Group getGroup() { return cGroup; }

		//"exception"
		public Keyword getExceptionKeyword_0() { return cExceptionKeyword_0; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1() { return cIdentifierAssignment_1; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_0() { return cIdentifierIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//members+=member*
		public Assignment getMembersAssignment_3() { return cMembersAssignment_3; }

		//member
		public RuleCall getMembersMemberParserRuleCall_3_0() { return cMembersMemberParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class Type_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "type_decl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAlias_typeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStruct_typeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUnion_typeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cEnum_typeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cNativeKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final RuleCall cConstr_forward_declParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//type_decl returns IDL::TypedefDef:
		//	alias_type | struct_type | union_type | enum_type | "native" ID | constr_forward_decl;
		public ParserRule getRule() { return rule; }

		//alias_type | struct_type | union_type | enum_type | "native" ID | constr_forward_decl
		public Alternatives getAlternatives() { return cAlternatives; }

		//alias_type
		public RuleCall getAlias_typeParserRuleCall_0() { return cAlias_typeParserRuleCall_0; }

		//struct_type
		public RuleCall getStruct_typeParserRuleCall_1() { return cStruct_typeParserRuleCall_1; }

		//union_type
		public RuleCall getUnion_typeParserRuleCall_2() { return cUnion_typeParserRuleCall_2; }

		//enum_type
		public RuleCall getEnum_typeParserRuleCall_3() { return cEnum_typeParserRuleCall_3; }

		//"native" ID
		public Group getGroup_4() { return cGroup_4; }

		//"native"
		public Keyword getNativeKeyword_4_0() { return cNativeKeyword_4_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_4_1() { return cIDTerminalRuleCall_4_1; }

		//constr_forward_decl
		public RuleCall getConstr_forward_declParserRuleCall_5() { return cConstr_forward_declParserRuleCall_5; }
	}

	public class Alias_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "alias_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTypedefKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cContainedTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cContainedTypeArray_type_specParserRuleCall_0_1_0 = (RuleCall)cContainedTypeAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTypedefKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cContainedTypeAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cContainedTypeSimple_type_specParserRuleCall_1_1_0_0 = (RuleCall)cContainedTypeAssignment_1_1_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_1_1_1_0 = (CrossReference)cSharedTypeAssignment_1_1_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_1_1_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_2_0 = (RuleCall)cIdentifierAssignment_1_2.eContents().get(0);
		
		//alias_type returns IDL::AliasDef:
		//	"typedef" containedType=array_type_spec | "typedef" (containedType=simple_type_spec | sharedType=[IDL::TypedefDef])
		//	identifier=ID;
		public ParserRule getRule() { return rule; }

		//"typedef" containedType=array_type_spec | "typedef" (containedType=simple_type_spec | sharedType=[IDL::TypedefDef])
		//identifier=ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//"typedef" containedType=array_type_spec
		public Group getGroup_0() { return cGroup_0; }

		//"typedef"
		public Keyword getTypedefKeyword_0_0() { return cTypedefKeyword_0_0; }

		//containedType=array_type_spec
		public Assignment getContainedTypeAssignment_0_1() { return cContainedTypeAssignment_0_1; }

		//array_type_spec
		public RuleCall getContainedTypeArray_type_specParserRuleCall_0_1_0() { return cContainedTypeArray_type_specParserRuleCall_0_1_0; }

		//"typedef" (containedType=simple_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID
		public Group getGroup_1() { return cGroup_1; }

		//"typedef"
		public Keyword getTypedefKeyword_1_0() { return cTypedefKeyword_1_0; }

		//containedType=simple_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//containedType=simple_type_spec
		public Assignment getContainedTypeAssignment_1_1_0() { return cContainedTypeAssignment_1_1_0; }

		//simple_type_spec
		public RuleCall getContainedTypeSimple_type_specParserRuleCall_1_1_0_0() { return cContainedTypeSimple_type_specParserRuleCall_1_1_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_1_1_1() { return cSharedTypeAssignment_1_1_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_1_1_1_0() { return cSharedTypeTypedefDefCrossReference_1_1_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1_2() { return cIdentifierAssignment_1_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_2_0() { return cIdentifierIDTerminalRuleCall_1_2_0; }
	}

	public class Array_type_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "array_type_spec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Assignment cContainedTypeAssignment_0_0 = (Assignment)cAlternatives_0.eContents().get(0);
		private final RuleCall cContainedTypeSimple_type_specParserRuleCall_0_0_0 = (RuleCall)cContainedTypeAssignment_0_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_0_1 = (Assignment)cAlternatives_0.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_0_1_0 = (CrossReference)cSharedTypeAssignment_0_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_0_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_0_1_0.eContents().get(1);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cBoundsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cBoundsConst_expParserRuleCall_2_1_0 = (RuleCall)cBoundsAssignment_2_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		/// *id_array
		//	:	ID ('['const_exp']')+
		//	;* /array_type_spec returns IDL::ArrayDef:
		//	(containedType=simple_type_spec | sharedType=[IDL::TypedefDef]) name=ID ("[" bounds+=const_exp "]")+;
		public ParserRule getRule() { return rule; }

		//(containedType=simple_type_spec | sharedType=[IDL::TypedefDef]) name=ID ("[" bounds+=const_exp "]")+
		public Group getGroup() { return cGroup; }

		//containedType=simple_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//containedType=simple_type_spec
		public Assignment getContainedTypeAssignment_0_0() { return cContainedTypeAssignment_0_0; }

		//simple_type_spec
		public RuleCall getContainedTypeSimple_type_specParserRuleCall_0_0_0() { return cContainedTypeSimple_type_specParserRuleCall_0_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_0_1() { return cSharedTypeAssignment_0_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_0_1_0() { return cSharedTypeTypedefDefCrossReference_0_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_0_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_0_1_0_1; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//("[" bounds+=const_exp "]")+
		public Group getGroup_2() { return cGroup_2; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2_0() { return cLeftSquareBracketKeyword_2_0; }

		//bounds+=const_exp
		public Assignment getBoundsAssignment_2_1() { return cBoundsAssignment_2_1; }

		//const_exp
		public RuleCall getBoundsConst_expParserRuleCall_2_1_0() { return cBoundsConst_expParserRuleCall_2_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2_2() { return cRightSquareBracketKeyword_2_2; }
	}

	public class Simple_type_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "simple_type_spec");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBase_type_specParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTemplate_type_specParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//simple_type_spec returns IDL::IDLType:
		//	base_type_spec | template_type_spec;
		public ParserRule getRule() { return rule; }

		//base_type_spec | template_type_spec
		public Alternatives getAlternatives() { return cAlternatives; }

		//base_type_spec
		public RuleCall getBase_type_specParserRuleCall_0() { return cBase_type_specParserRuleCall_0; }

		//template_type_spec
		public RuleCall getTemplate_type_specParserRuleCall_1() { return cTemplate_type_specParserRuleCall_1; }
	}

	public class Base_type_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "base_type_spec");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitive_defParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cKindObject_typeEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		
		//base_type_spec returns IDL::PrimitiveDef:
		//	primitive_def | kind=object_type;
		public ParserRule getRule() { return rule; }

		//primitive_def | kind=object_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//primitive_def
		public RuleCall getPrimitive_defParserRuleCall_0() { return cPrimitive_defParserRuleCall_0; }

		//kind=object_type
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//object_type
		public RuleCall getKindObject_typeEnumRuleCall_1_0() { return cKindObject_typeEnumRuleCall_1_0; }
	}

	public class Template_type_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "template_type_spec");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSequence_typeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringdef_typeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWide_stringdef_typeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFixed_pt_typeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//template_type_spec returns IDL::IDLType:
		//	sequence_type | stringdef_type | wide_stringdef_type | fixed_pt_type;
		public ParserRule getRule() { return rule; }

		//sequence_type | stringdef_type | wide_stringdef_type | fixed_pt_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//sequence_type
		public RuleCall getSequence_typeParserRuleCall_0() { return cSequence_typeParserRuleCall_0; }

		//stringdef_type
		public RuleCall getStringdef_typeParserRuleCall_1() { return cStringdef_typeParserRuleCall_1; }

		//wide_stringdef_type
		public RuleCall getWide_stringdef_typeParserRuleCall_2() { return cWide_stringdef_typeParserRuleCall_2; }

		//fixed_pt_type
		public RuleCall getFixed_pt_typeParserRuleCall_3() { return cFixed_pt_typeParserRuleCall_3; }
	}

	public class Constr_type_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "constr_type_spec");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStruct_typeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnion_typeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEnum_typeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//constr_type_spec returns IDL::TypedefDef:
		//	struct_type | union_type | enum_type;
		public ParserRule getRule() { return rule; }

		//struct_type | union_type | enum_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//struct_type
		public RuleCall getStruct_typeParserRuleCall_0() { return cStruct_typeParserRuleCall_0; }

		//union_type
		public RuleCall getUnion_typeParserRuleCall_1() { return cUnion_typeParserRuleCall_1; }

		//enum_type
		public RuleCall getEnum_typeParserRuleCall_2() { return cEnum_typeParserRuleCall_2; }
	}

	public class Struct_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "struct_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStructKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdentifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_0 = (RuleCall)cIdentifierAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMembersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMembersMemberParserRuleCall_3_0 = (RuleCall)cMembersAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//struct_type returns IDL::StructDef:
		//	"struct" identifier=ID "{" members+=member+ "}";
		public ParserRule getRule() { return rule; }

		//"struct" identifier=ID "{" members+=member+ "}"
		public Group getGroup() { return cGroup; }

		//"struct"
		public Keyword getStructKeyword_0() { return cStructKeyword_0; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1() { return cIdentifierAssignment_1; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_0() { return cIdentifierIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//members+=member+
		public Assignment getMembersAssignment_3() { return cMembersAssignment_3; }

		//member
		public RuleCall getMembersMemberParserRuleCall_3_0() { return cMembersMemberParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class MemberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "member");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cContainedTypeAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cContainedTypeArray_type_specParserRuleCall_0_0_0 = (RuleCall)cContainedTypeAssignment_0_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cContainedTypeAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cContainedTypeSimple_type_specParserRuleCall_1_0_0 = (RuleCall)cContainedTypeAssignment_1_0.eContents().get(0);
		private final Assignment cIdentifierAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_1_0 = (RuleCall)cIdentifierAssignment_1_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cContainedTypeAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cContainedTypeStruct_typeParserRuleCall_2_0_0 = (RuleCall)cContainedTypeAssignment_2_0.eContents().get(0);
		private final Assignment cIdentifierAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_2_1_0 = (RuleCall)cIdentifierAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Assignment cSharedTypeAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final CrossReference cSharedTypeTypedefDefCrossReference_3_0_0 = (CrossReference)cSharedTypeAssignment_3_0.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_3_0_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_3_0_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_3_1_0 = (RuleCall)cIdentifierAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		
		//member returns IDL::Field:
		//	containedType=array_type_spec / *identifier= id_array* / ";" | containedType=simple_type_spec identifier=ID ";" |
		//	containedType=struct_type identifier=ID ";" | sharedType=[IDL::TypedefDef] identifier=ID ";";
		public ParserRule getRule() { return rule; }

		//containedType=array_type_spec / *identifier= id_array* / ";" | containedType=simple_type_spec identifier=ID ";" |
		//containedType=struct_type identifier=ID ";" | sharedType=[IDL::TypedefDef] identifier=ID ";"
		public Alternatives getAlternatives() { return cAlternatives; }

		//containedType=array_type_spec / *identifier= id_array* / ";"
		public Group getGroup_0() { return cGroup_0; }

		//containedType=array_type_spec
		public Assignment getContainedTypeAssignment_0_0() { return cContainedTypeAssignment_0_0; }

		//array_type_spec
		public RuleCall getContainedTypeArray_type_specParserRuleCall_0_0_0() { return cContainedTypeArray_type_specParserRuleCall_0_0_0; }

		/// *identifier= id_array* / ";"
		public Keyword getSemicolonKeyword_0_1() { return cSemicolonKeyword_0_1; }

		//containedType=simple_type_spec identifier=ID ";"
		public Group getGroup_1() { return cGroup_1; }

		//containedType=simple_type_spec
		public Assignment getContainedTypeAssignment_1_0() { return cContainedTypeAssignment_1_0; }

		//simple_type_spec
		public RuleCall getContainedTypeSimple_type_specParserRuleCall_1_0_0() { return cContainedTypeSimple_type_specParserRuleCall_1_0_0; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1_1() { return cIdentifierAssignment_1_1; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_1_0() { return cIdentifierIDTerminalRuleCall_1_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1_2() { return cSemicolonKeyword_1_2; }

		//containedType=struct_type identifier=ID ";"
		public Group getGroup_2() { return cGroup_2; }

		//containedType=struct_type
		public Assignment getContainedTypeAssignment_2_0() { return cContainedTypeAssignment_2_0; }

		//struct_type
		public RuleCall getContainedTypeStruct_typeParserRuleCall_2_0_0() { return cContainedTypeStruct_typeParserRuleCall_2_0_0; }

		//identifier=ID
		public Assignment getIdentifierAssignment_2_1() { return cIdentifierAssignment_2_1; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_2_1_0() { return cIdentifierIDTerminalRuleCall_2_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2_2() { return cSemicolonKeyword_2_2; }

		//sharedType=[IDL::TypedefDef] identifier=ID ";"
		public Group getGroup_3() { return cGroup_3; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_3_0() { return cSharedTypeAssignment_3_0; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_3_0_0() { return cSharedTypeTypedefDefCrossReference_3_0_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_3_0_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_3_0_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_3_1() { return cIdentifierAssignment_3_1; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_3_1_0() { return cIdentifierIDTerminalRuleCall_3_1_0; }

		//";"
		public Keyword getSemicolonKeyword_3_2() { return cSemicolonKeyword_3_2; }
	}

	public class Union_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "union_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdentifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_0 = (RuleCall)cIdentifierAssignment_1.eContents().get(0);
		private final Keyword cSwitchKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cContainedDiscrimAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cContainedDiscrimSwitch_type_spec_contParserRuleCall_4_0_0 = (RuleCall)cContainedDiscrimAssignment_4_0.eContents().get(0);
		private final Assignment cSharedDiscrimAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final CrossReference cSharedDiscrimEnumDefCrossReference_4_1_0 = (CrossReference)cSharedDiscrimAssignment_4_1.eContents().get(0);
		private final RuleCall cSharedDiscrimEnumDefIDTerminalRuleCall_4_1_0_1 = (RuleCall)cSharedDiscrimEnumDefCrossReference_4_1_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cUnionMembersAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cUnionMembersCase_stmtParserRuleCall_7_0 = (RuleCall)cUnionMembersAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//union_type returns IDL::UnionDef:
		//	"union" identifier=ID "switch" "(" (containedDiscrim=switch_type_spec_cont | sharedDiscrim=[IDL::EnumDef]) ")" "{"
		//	unionMembers+=case_stmt+ "}";
		public ParserRule getRule() { return rule; }

		//"union" identifier=ID "switch" "(" (containedDiscrim=switch_type_spec_cont | sharedDiscrim=[IDL::EnumDef]) ")" "{"
		//unionMembers+=case_stmt+ "}"
		public Group getGroup() { return cGroup; }

		//"union"
		public Keyword getUnionKeyword_0() { return cUnionKeyword_0; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1() { return cIdentifierAssignment_1; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_0() { return cIdentifierIDTerminalRuleCall_1_0; }

		//"switch"
		public Keyword getSwitchKeyword_2() { return cSwitchKeyword_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }

		//containedDiscrim=switch_type_spec_cont | sharedDiscrim=[IDL::EnumDef]
		public Alternatives getAlternatives_4() { return cAlternatives_4; }

		//containedDiscrim=switch_type_spec_cont
		public Assignment getContainedDiscrimAssignment_4_0() { return cContainedDiscrimAssignment_4_0; }

		//switch_type_spec_cont
		public RuleCall getContainedDiscrimSwitch_type_spec_contParserRuleCall_4_0_0() { return cContainedDiscrimSwitch_type_spec_contParserRuleCall_4_0_0; }

		//sharedDiscrim=[IDL::EnumDef]
		public Assignment getSharedDiscrimAssignment_4_1() { return cSharedDiscrimAssignment_4_1; }

		//[IDL::EnumDef]
		public CrossReference getSharedDiscrimEnumDefCrossReference_4_1_0() { return cSharedDiscrimEnumDefCrossReference_4_1_0; }

		//ID
		public RuleCall getSharedDiscrimEnumDefIDTerminalRuleCall_4_1_0_1() { return cSharedDiscrimEnumDefIDTerminalRuleCall_4_1_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }

		//unionMembers+=case_stmt+
		public Assignment getUnionMembersAssignment_7() { return cUnionMembersAssignment_7; }

		//case_stmt
		public RuleCall getUnionMembersCase_stmtParserRuleCall_7_0() { return cUnionMembersCase_stmtParserRuleCall_7_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}

	public class Switch_type_spec_contElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "switch_type_spec_cont");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInteger_typeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cPrimitiveDefAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cKindAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cKindChar_typeEnumRuleCall_1_1_0 = (RuleCall)cKindAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cPrimitiveDefAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cKindAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cKindBoolean_typeEnumRuleCall_2_1_0 = (RuleCall)cKindAssignment_2_1.eContents().get(0);
		private final RuleCall cEnum_typeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//switch_type_spec_cont returns IDL::IDLType:
		//	integer_type | {IDL::PrimitiveDef} kind=char_type | {IDL::PrimitiveDef} kind=boolean_type | enum_type;
		public ParserRule getRule() { return rule; }

		//integer_type | {IDL::PrimitiveDef} kind=char_type | {IDL::PrimitiveDef} kind=boolean_type | enum_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//integer_type
		public RuleCall getInteger_typeParserRuleCall_0() { return cInteger_typeParserRuleCall_0; }

		//{IDL::PrimitiveDef} kind=char_type
		public Group getGroup_1() { return cGroup_1; }

		//{IDL::PrimitiveDef}
		public Action getPrimitiveDefAction_1_0() { return cPrimitiveDefAction_1_0; }

		//kind=char_type
		public Assignment getKindAssignment_1_1() { return cKindAssignment_1_1; }

		//char_type
		public RuleCall getKindChar_typeEnumRuleCall_1_1_0() { return cKindChar_typeEnumRuleCall_1_1_0; }

		//{IDL::PrimitiveDef} kind=boolean_type
		public Group getGroup_2() { return cGroup_2; }

		//{IDL::PrimitiveDef}
		public Action getPrimitiveDefAction_2_0() { return cPrimitiveDefAction_2_0; }

		//kind=boolean_type
		public Assignment getKindAssignment_2_1() { return cKindAssignment_2_1; }

		//boolean_type
		public RuleCall getKindBoolean_typeEnumRuleCall_2_1_0() { return cKindBoolean_typeEnumRuleCall_2_1_0; }

		//enum_type
		public RuleCall getEnum_typeParserRuleCall_3() { return cEnum_typeParserRuleCall_3; }
	}

	public class Case_stmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "case_stmt");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final Group cGroup_0_0_0 = (Group)cAlternatives_0_0.eContents().get(0);
		private final Keyword cCaseKeyword_0_0_0_0 = (Keyword)cGroup_0_0_0.eContents().get(0);
		private final Assignment cLabelAssignment_0_0_0_1 = (Assignment)cGroup_0_0_0.eContents().get(1);
		private final RuleCall cLabelConst_expParserRuleCall_0_0_0_1_0 = (RuleCall)cLabelAssignment_0_0_0_1.eContents().get(0);
		private final Keyword cColonKeyword_0_0_0_2 = (Keyword)cGroup_0_0_0.eContents().get(2);
		private final Group cGroup_0_0_1 = (Group)cAlternatives_0_0.eContents().get(1);
		private final Keyword cDefaultKeyword_0_0_1_0 = (Keyword)cGroup_0_0_1.eContents().get(0);
		private final Keyword cColonKeyword_0_0_1_1 = (Keyword)cGroup_0_0_1.eContents().get(1);
		private final Assignment cContainedTypeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cContainedTypeArray_type_specParserRuleCall_0_1_0 = (RuleCall)cContainedTypeAssignment_0_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Keyword cCaseKeyword_1_0_0_0 = (Keyword)cGroup_1_0_0.eContents().get(0);
		private final Assignment cLabelAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final RuleCall cLabelConst_expParserRuleCall_1_0_0_1_0 = (RuleCall)cLabelAssignment_1_0_0_1.eContents().get(0);
		private final Keyword cColonKeyword_1_0_0_2 = (Keyword)cGroup_1_0_0.eContents().get(2);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Keyword cDefaultKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Keyword cColonKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cContainedTypeAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final RuleCall cContainedTypeSimple_type_specParserRuleCall_1_1_0_0 = (RuleCall)cContainedTypeAssignment_1_1_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_1_1_1 = (Assignment)cAlternatives_1_1.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_1_1_1_0 = (CrossReference)cSharedTypeAssignment_1_1_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_1_1_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_2_0 = (RuleCall)cIdentifierAssignment_1_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//case_stmt returns IDL::UnionField:
		//	("case" label+=const_exp ":" | / *label+=* / "default" ":")+ containedType=array_type_spec / *identifier= id_array* / ";"
		//	| ("case" label+=const_exp ":" | / *label+=* / "default" ":")+ (containedType=simple_type_spec |
		//	sharedType=[IDL::TypedefDef]) identifier=ID ";";
		public ParserRule getRule() { return rule; }

		//("case" label+=const_exp ":" | / *label+=* / "default" ":")+ containedType=array_type_spec / *identifier= id_array* / ";" |
		//("case" label+=const_exp ":" | / *label+=* / "default" ":")+ (containedType=simple_type_spec |
		//sharedType=[IDL::TypedefDef]) identifier=ID ";"
		public Alternatives getAlternatives() { return cAlternatives; }

		//("case" label+=const_exp ":" | / *label+=* / "default" ":")+ containedType=array_type_spec / *identifier= id_array* / ";"
		public Group getGroup_0() { return cGroup_0; }

		//("case" label+=const_exp ":" | / *label+=* / "default" ":")+
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//"case" label+=const_exp ":"
		public Group getGroup_0_0_0() { return cGroup_0_0_0; }

		//"case"
		public Keyword getCaseKeyword_0_0_0_0() { return cCaseKeyword_0_0_0_0; }

		//label+=const_exp
		public Assignment getLabelAssignment_0_0_0_1() { return cLabelAssignment_0_0_0_1; }

		//const_exp
		public RuleCall getLabelConst_expParserRuleCall_0_0_0_1_0() { return cLabelConst_expParserRuleCall_0_0_0_1_0; }

		//":"
		public Keyword getColonKeyword_0_0_0_2() { return cColonKeyword_0_0_0_2; }

		/// *label+=* / "default" ":"
		public Group getGroup_0_0_1() { return cGroup_0_0_1; }

		/// *label+=* / "default"
		public Keyword getDefaultKeyword_0_0_1_0() { return cDefaultKeyword_0_0_1_0; }

		//":"
		public Keyword getColonKeyword_0_0_1_1() { return cColonKeyword_0_0_1_1; }

		//containedType=array_type_spec
		public Assignment getContainedTypeAssignment_0_1() { return cContainedTypeAssignment_0_1; }

		//array_type_spec
		public RuleCall getContainedTypeArray_type_specParserRuleCall_0_1_0() { return cContainedTypeArray_type_specParserRuleCall_0_1_0; }

		/// *identifier= id_array* / ";"
		public Keyword getSemicolonKeyword_0_2() { return cSemicolonKeyword_0_2; }

		//("case" label+=const_exp ":" | / *label+=* / "default" ":")+ (containedType=simple_type_spec |
		//sharedType=[IDL::TypedefDef]) identifier=ID ";"
		public Group getGroup_1() { return cGroup_1; }

		//("case" label+=const_exp ":" | / *label+=* / "default" ":")+
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//"case" label+=const_exp ":"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//"case"
		public Keyword getCaseKeyword_1_0_0_0() { return cCaseKeyword_1_0_0_0; }

		//label+=const_exp
		public Assignment getLabelAssignment_1_0_0_1() { return cLabelAssignment_1_0_0_1; }

		//const_exp
		public RuleCall getLabelConst_expParserRuleCall_1_0_0_1_0() { return cLabelConst_expParserRuleCall_1_0_0_1_0; }

		//":"
		public Keyword getColonKeyword_1_0_0_2() { return cColonKeyword_1_0_0_2; }

		/// *label+=* / "default" ":"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		/// *label+=* / "default"
		public Keyword getDefaultKeyword_1_0_1_0() { return cDefaultKeyword_1_0_1_0; }

		//":"
		public Keyword getColonKeyword_1_0_1_1() { return cColonKeyword_1_0_1_1; }

		//containedType=simple_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//containedType=simple_type_spec
		public Assignment getContainedTypeAssignment_1_1_0() { return cContainedTypeAssignment_1_1_0; }

		//simple_type_spec
		public RuleCall getContainedTypeSimple_type_specParserRuleCall_1_1_0_0() { return cContainedTypeSimple_type_specParserRuleCall_1_1_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_1_1_1() { return cSharedTypeAssignment_1_1_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_1_1_1_0() { return cSharedTypeTypedefDefCrossReference_1_1_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_1_1_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1_2() { return cIdentifierAssignment_1_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_2_0() { return cIdentifierIDTerminalRuleCall_1_2_0; }

		//";"
		public Keyword getSemicolonKeyword_1_3() { return cSemicolonKeyword_1_3; }
	}

	public class Enum_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enum_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdentifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_1_0 = (RuleCall)cIdentifierAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cMembersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMembersEnum_memberParserRuleCall_3_0 = (RuleCall)cMembersAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cMembersAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cMembersEnum_memberParserRuleCall_4_1_0 = (RuleCall)cMembersAssignment_4_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//enum_type returns IDL::EnumDef:
		//	"enum" identifier=ID "{" members+=enum_member ("," members+=enum_member)* "}";
		public ParserRule getRule() { return rule; }

		//"enum" identifier=ID "{" members+=enum_member ("," members+=enum_member)* "}"
		public Group getGroup() { return cGroup; }

		//"enum"
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }

		//identifier=ID
		public Assignment getIdentifierAssignment_1() { return cIdentifierAssignment_1; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_1_0() { return cIdentifierIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//members+=enum_member
		public Assignment getMembersAssignment_3() { return cMembersAssignment_3; }

		//enum_member
		public RuleCall getMembersEnum_memberParserRuleCall_3_0() { return cMembersEnum_memberParserRuleCall_3_0; }

		//("," members+=enum_member)*
		public Group getGroup_4() { return cGroup_4; }

		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }

		//members+=enum_member
		public Assignment getMembersAssignment_4_1() { return cMembersAssignment_4_1; }

		//enum_member
		public RuleCall getMembersEnum_memberParserRuleCall_4_1_0() { return cMembersEnum_memberParserRuleCall_4_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class Enum_memberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "enum_member");
		private final Assignment cIdentifierAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdentifierIDTerminalRuleCall_0 = (RuleCall)cIdentifierAssignment.eContents().get(0);
		
		//enum_member returns IDL::EnumMember:
		//	identifier=ID;
		public ParserRule getRule() { return rule; }

		//identifier=ID
		public Assignment getIdentifierAssignment() { return cIdentifierAssignment; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_0() { return cIdentifierIDTerminalRuleCall_0; }
	}

	public class Constr_forward_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "constr_forward_decl");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cStructKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cUnionKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//constr_forward_decl returns ecore::EString:
		//	"struct" ID | "union" ID;
		public ParserRule getRule() { return rule; }

		//"struct" ID | "union" ID
		public Alternatives getAlternatives() { return cAlternatives; }

		//"struct" ID
		public Group getGroup_0() { return cGroup_0; }

		//"struct"
		public Keyword getStructKeyword_0_0() { return cStructKeyword_0_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_1() { return cIDTerminalRuleCall_0_1; }

		//"union" ID
		public Group getGroup_1() { return cGroup_1; }

		//"union"
		public Keyword getUnionKeyword_1_0() { return cUnionKeyword_1_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}

	public class Const_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "const_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cContainedTypeAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cContainedTypeConst_typeParserRuleCall_1_0_0 = (RuleCall)cContainedTypeAssignment_1_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final CrossReference cSharedTypeAliasDefCrossReference_1_1_0 = (CrossReference)cSharedTypeAssignment_1_1.eContents().get(0);
		private final RuleCall cSharedTypeAliasDefIDTerminalRuleCall_1_1_0_1 = (RuleCall)cSharedTypeAliasDefCrossReference_1_1_0.eContents().get(1);
		private final Assignment cIdentifierAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIdentifierIDTerminalRuleCall_2_0 = (RuleCall)cIdentifierAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConstValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConstValueConst_expParserRuleCall_4_0 = (RuleCall)cConstValueAssignment_4.eContents().get(0);
		
		//// FIXME: las constantes de tipo FixedDef tienen un value distinto (no const_exp) 12.34D
		//// TODO: implementar plantilla xtend para completar los datos de los elementos containedType
		////       como por ejemplo el fixedDef y sus campos parte real y parte flotante
		//// TODO: comprobar con xtend o cheq que el sharedType es un alias de un tipo básico!!
		//const_decl returns IDL::ConstantDef:
		//	"const" (containedType=const_type | sharedType=[IDL::AliasDef]) identifier=ID "=" constValue=const_exp;
		public ParserRule getRule() { return rule; }

		//"const" (containedType=const_type | sharedType=[IDL::AliasDef]) identifier=ID "=" constValue=const_exp
		public Group getGroup() { return cGroup; }

		//"const"
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }

		//containedType=const_type | sharedType=[IDL::AliasDef]
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//containedType=const_type
		public Assignment getContainedTypeAssignment_1_0() { return cContainedTypeAssignment_1_0; }

		//const_type
		public RuleCall getContainedTypeConst_typeParserRuleCall_1_0_0() { return cContainedTypeConst_typeParserRuleCall_1_0_0; }

		//sharedType=[IDL::AliasDef]
		public Assignment getSharedTypeAssignment_1_1() { return cSharedTypeAssignment_1_1; }

		//[IDL::AliasDef]
		public CrossReference getSharedTypeAliasDefCrossReference_1_1_0() { return cSharedTypeAliasDefCrossReference_1_1_0; }

		//ID
		public RuleCall getSharedTypeAliasDefIDTerminalRuleCall_1_1_0_1() { return cSharedTypeAliasDefIDTerminalRuleCall_1_1_0_1; }

		//identifier=ID
		public Assignment getIdentifierAssignment_2() { return cIdentifierAssignment_2; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_2_0() { return cIdentifierIDTerminalRuleCall_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//constValue=const_exp
		public Assignment getConstValueAssignment_4() { return cConstValueAssignment_4; }

		//const_exp
		public RuleCall getConstValueConst_expParserRuleCall_4_0() { return cConstValueConst_expParserRuleCall_4_0; }
	}

	public class Const_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "const_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimitive_defParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringdef_typeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWide_stringdef_typeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFixed_pt_const_typeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//const_type returns IDL::IDLType:
		//	primitive_def | stringdef_type | wide_stringdef_type | fixed_pt_const_type;
		public ParserRule getRule() { return rule; }

		//primitive_def | stringdef_type | wide_stringdef_type | fixed_pt_const_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//primitive_def
		public RuleCall getPrimitive_defParserRuleCall_0() { return cPrimitive_defParserRuleCall_0; }

		//stringdef_type
		public RuleCall getStringdef_typeParserRuleCall_1() { return cStringdef_typeParserRuleCall_1; }

		//wide_stringdef_type
		public RuleCall getWide_stringdef_typeParserRuleCall_2() { return cWide_stringdef_typeParserRuleCall_2; }

		//fixed_pt_const_type
		public RuleCall getFixed_pt_const_typeParserRuleCall_3() { return cFixed_pt_const_typeParserRuleCall_3; }
	}

	public class Primitive_defElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "primitive_def");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInteger_typeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFloating_pt_typeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCharstr_typeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cOther_typeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//primitive_def returns IDL::PrimitiveDef:
		//	integer_type | floating_pt_type | charstr_type | other_type;
		public ParserRule getRule() { return rule; }

		//integer_type | floating_pt_type | charstr_type | other_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//integer_type
		public RuleCall getInteger_typeParserRuleCall_0() { return cInteger_typeParserRuleCall_0; }

		//floating_pt_type
		public RuleCall getFloating_pt_typeParserRuleCall_1() { return cFloating_pt_typeParserRuleCall_1; }

		//charstr_type
		public RuleCall getCharstr_typeParserRuleCall_2() { return cCharstr_typeParserRuleCall_2; }

		//other_type
		public RuleCall getOther_typeParserRuleCall_3() { return cOther_typeParserRuleCall_3; }
	}

	public class Sequence_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "sequence_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSequenceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cContainedTypeAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cContainedTypeSimple_type_specParserRuleCall_2_0_0 = (RuleCall)cContainedTypeAssignment_2_0.eContents().get(0);
		private final Assignment cSharedTypeAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final CrossReference cSharedTypeTypedefDefCrossReference_2_1_0 = (CrossReference)cSharedTypeAssignment_2_1.eContents().get(0);
		private final RuleCall cSharedTypeTypedefDefIDTerminalRuleCall_2_1_0_1 = (RuleCall)cSharedTypeTypedefDefCrossReference_2_1_0.eContents().get(1);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cBoundAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cBoundConst_expParserRuleCall_3_1_0 = (RuleCall)cBoundAssignment_3_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		////----------------------------
		////		DECLARATORS
		////----------------------------
		/// *
		//declarators
		//	:	declarator ( ',' declarator )*
		//	;
		//
		//simple_declarators
		//	:	(simple_declarator (',' simple_declarator)*)
		//	;
		//
		//declarator
		//	:	simple_declarator
		//	|	complex_declarator
		//	;
		//
		//simple_declarator
		//	:	ID
		//	;
		//
		//// TODO: añadir el arraydef!!!
		//complex_declarator
		//	:	ID ('[' const_exp ']')+
		//	;
		// * ///---------------------------
		//// TEMPLATE TYPES
		////---------------------------
		//sequence_type returns IDL::SequenceDef:
		//	"sequence" "<" (containedType=simple_type_spec | sharedType=[IDL::TypedefDef]) ("," bound=const_exp)? ">";
		public ParserRule getRule() { return rule; }

		//"sequence" "<" (containedType=simple_type_spec | sharedType=[IDL::TypedefDef]) ("," bound=const_exp)? ">"
		public Group getGroup() { return cGroup; }

		//"sequence"
		public Keyword getSequenceKeyword_0() { return cSequenceKeyword_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//containedType=simple_type_spec | sharedType=[IDL::TypedefDef]
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//containedType=simple_type_spec
		public Assignment getContainedTypeAssignment_2_0() { return cContainedTypeAssignment_2_0; }

		//simple_type_spec
		public RuleCall getContainedTypeSimple_type_specParserRuleCall_2_0_0() { return cContainedTypeSimple_type_specParserRuleCall_2_0_0; }

		//sharedType=[IDL::TypedefDef]
		public Assignment getSharedTypeAssignment_2_1() { return cSharedTypeAssignment_2_1; }

		//[IDL::TypedefDef]
		public CrossReference getSharedTypeTypedefDefCrossReference_2_1_0() { return cSharedTypeTypedefDefCrossReference_2_1_0; }

		//ID
		public RuleCall getSharedTypeTypedefDefIDTerminalRuleCall_2_1_0_1() { return cSharedTypeTypedefDefIDTerminalRuleCall_2_1_0_1; }

		//("," bound=const_exp)?
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//bound=const_exp
		public Assignment getBoundAssignment_3_1() { return cBoundAssignment_3_1; }

		//const_exp
		public RuleCall getBoundConst_expParserRuleCall_3_1_0() { return cBoundConst_expParserRuleCall_3_1_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_4() { return cGreaterThanSignKeyword_4; }
	}

	public class Stringdef_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "stringdef_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStringKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBoundAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBoundConst_expParserRuleCall_2_0 = (RuleCall)cBoundAssignment_2.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//stringdef_type returns IDL::StringDef:
		//	"string" "<" bound=const_exp ">";
		public ParserRule getRule() { return rule; }

		//"string" "<" bound=const_exp ">"
		public Group getGroup() { return cGroup; }

		//"string"
		public Keyword getStringKeyword_0() { return cStringKeyword_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//bound=const_exp
		public Assignment getBoundAssignment_2() { return cBoundAssignment_2; }

		//const_exp
		public RuleCall getBoundConst_expParserRuleCall_2_0() { return cBoundConst_expParserRuleCall_2_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }
	}

	public class Wide_stringdef_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "wide_stringdef_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWstringKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBoundAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBoundConst_expParserRuleCall_2_0 = (RuleCall)cBoundAssignment_2.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//wide_stringdef_type returns IDL::WstringDef:
		//	"wstring" "<" bound=const_exp ">";
		public ParserRule getRule() { return rule; }

		//"wstring" "<" bound=const_exp ">"
		public Group getGroup() { return cGroup; }

		//"wstring"
		public Keyword getWstringKeyword_0() { return cWstringKeyword_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//bound=const_exp
		public Assignment getBoundAssignment_2() { return cBoundAssignment_2; }

		//const_exp
		public RuleCall getBoundConst_expParserRuleCall_2_0() { return cBoundConst_expParserRuleCall_2_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_3() { return cGreaterThanSignKeyword_3; }
	}

	public class Fixed_pt_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fixed_pt_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFixedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDigitsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDigitsConst_expParserRuleCall_2_0 = (RuleCall)cDigitsAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cScaleAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cScaleConst_expParserRuleCall_4_0 = (RuleCall)cScaleAssignment_4.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//fixed_pt_type returns IDL::FixedDef:
		//	"fixed" "<" digits=const_exp "," scale=const_exp ">";
		public ParserRule getRule() { return rule; }

		//"fixed" "<" digits=const_exp "," scale=const_exp ">"
		public Group getGroup() { return cGroup; }

		//"fixed"
		public Keyword getFixedKeyword_0() { return cFixedKeyword_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//digits=const_exp
		public Assignment getDigitsAssignment_2() { return cDigitsAssignment_2; }

		//const_exp
		public RuleCall getDigitsConst_expParserRuleCall_2_0() { return cDigitsConst_expParserRuleCall_2_0; }

		//","
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//scale=const_exp
		public Assignment getScaleAssignment_4() { return cScaleAssignment_4; }

		//const_exp
		public RuleCall getScaleConst_expParserRuleCall_4_0() { return cScaleConst_expParserRuleCall_4_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_5() { return cGreaterThanSignKeyword_5; }
	}

	public class Floating_pt_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "floating_pt_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cKindFloat_typeEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cKindDouble_typeEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		private final Assignment cKindAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cKindLongdouble_typeParserRuleCall_2_0 = (RuleCall)cKindAssignment_2.eContents().get(0);
		
		////---------------------------
		//// BASE TYPES
		////---------------------------
		//floating_pt_type returns IDL::PrimitiveDef:
		//	kind=float_type | kind=double_type | kind=longdouble_type;
		public ParserRule getRule() { return rule; }

		//kind=float_type | kind=double_type | kind=longdouble_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//kind=float_type
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }

		//float_type
		public RuleCall getKindFloat_typeEnumRuleCall_0_0() { return cKindFloat_typeEnumRuleCall_0_0; }

		//kind=double_type
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//double_type
		public RuleCall getKindDouble_typeEnumRuleCall_1_0() { return cKindDouble_typeEnumRuleCall_1_0; }

		//kind=longdouble_type
		public Assignment getKindAssignment_2() { return cKindAssignment_2; }

		//longdouble_type
		public RuleCall getKindLongdouble_typeParserRuleCall_2_0() { return cKindLongdouble_typeParserRuleCall_2_0; }
	}

	public class Longdouble_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "longdouble_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLongKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cDoubleKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//longdouble_type returns IDL::PrimitiveKind:
		//	"long" "double";
		public ParserRule getRule() { return rule; }

		//"long" "double"
		public Group getGroup() { return cGroup; }

		//"long"
		public Keyword getLongKeyword_0() { return cLongKeyword_0; }

		//"double"
		public Keyword getDoubleKeyword_1() { return cDoubleKeyword_1; }
	}

	public class Integer_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "integer_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cKindShort_typeEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cKindLong_typeEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		private final Assignment cKindAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cKindLonglong_typeParserRuleCall_2_0 = (RuleCall)cKindAssignment_2.eContents().get(0);
		private final Assignment cKindAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cKindUshort_typeParserRuleCall_3_0 = (RuleCall)cKindAssignment_3.eContents().get(0);
		private final Assignment cKindAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cKindUlong_typeParserRuleCall_4_0 = (RuleCall)cKindAssignment_4.eContents().get(0);
		private final Assignment cKindAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cKindUlonglong_typeParserRuleCall_5_0 = (RuleCall)cKindAssignment_5.eContents().get(0);
		
		//integer_type returns IDL::PrimitiveDef:
		//	kind=short_type | kind=long_type | kind=longlong_type | kind=ushort_type | kind=ulong_type | kind=ulonglong_type;
		public ParserRule getRule() { return rule; }

		//kind=short_type | kind=long_type | kind=longlong_type | kind=ushort_type | kind=ulong_type | kind=ulonglong_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//kind=short_type
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }

		//short_type
		public RuleCall getKindShort_typeEnumRuleCall_0_0() { return cKindShort_typeEnumRuleCall_0_0; }

		//kind=long_type
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//long_type
		public RuleCall getKindLong_typeEnumRuleCall_1_0() { return cKindLong_typeEnumRuleCall_1_0; }

		//kind=longlong_type
		public Assignment getKindAssignment_2() { return cKindAssignment_2; }

		//longlong_type
		public RuleCall getKindLonglong_typeParserRuleCall_2_0() { return cKindLonglong_typeParserRuleCall_2_0; }

		//kind=ushort_type
		public Assignment getKindAssignment_3() { return cKindAssignment_3; }

		//ushort_type
		public RuleCall getKindUshort_typeParserRuleCall_3_0() { return cKindUshort_typeParserRuleCall_3_0; }

		//kind=ulong_type
		public Assignment getKindAssignment_4() { return cKindAssignment_4; }

		//ulong_type
		public RuleCall getKindUlong_typeParserRuleCall_4_0() { return cKindUlong_typeParserRuleCall_4_0; }

		//kind=ulonglong_type
		public Assignment getKindAssignment_5() { return cKindAssignment_5; }

		//ulonglong_type
		public RuleCall getKindUlonglong_typeParserRuleCall_5_0() { return cKindUlonglong_typeParserRuleCall_5_0; }
	}

	public class Longlong_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "longlong_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLongKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLongKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//longlong_type returns IDL::PrimitiveKind:
		//	"long" "long";
		public ParserRule getRule() { return rule; }

		//"long" "long"
		public Group getGroup() { return cGroup; }

		//"long"
		public Keyword getLongKeyword_0() { return cLongKeyword_0; }

		//"long"
		public Keyword getLongKeyword_1() { return cLongKeyword_1; }
	}

	public class Ushort_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ushort_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnsignedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cShortKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ushort_type returns IDL::PrimitiveKind:
		//	"unsigned" "short";
		public ParserRule getRule() { return rule; }

		//"unsigned" "short"
		public Group getGroup() { return cGroup; }

		//"unsigned"
		public Keyword getUnsignedKeyword_0() { return cUnsignedKeyword_0; }

		//"short"
		public Keyword getShortKeyword_1() { return cShortKeyword_1; }
	}

	public class Ulong_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ulong_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnsignedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLongKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//ulong_type returns IDL::PrimitiveKind:
		//	"unsigned" "long";
		public ParserRule getRule() { return rule; }

		//"unsigned" "long"
		public Group getGroup() { return cGroup; }

		//"unsigned"
		public Keyword getUnsignedKeyword_0() { return cUnsignedKeyword_0; }

		//"long"
		public Keyword getLongKeyword_1() { return cLongKeyword_1; }
	}

	public class Ulonglong_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ulonglong_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUnsignedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLongKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLongKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ulonglong_type returns IDL::PrimitiveKind:
		//	"unsigned" "long" "long";
		public ParserRule getRule() { return rule; }

		//"unsigned" "long" "long"
		public Group getGroup() { return cGroup; }

		//"unsigned"
		public Keyword getUnsignedKeyword_0() { return cUnsignedKeyword_0; }

		//"long"
		public Keyword getLongKeyword_1() { return cLongKeyword_1; }

		//"long"
		public Keyword getLongKeyword_2() { return cLongKeyword_2; }
	}

	public class Charstr_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "charstr_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cKindChar_typeEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cKindWide_char_typeEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		private final Assignment cKindAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cKindString_typeEnumRuleCall_2_0 = (RuleCall)cKindAssignment_2.eContents().get(0);
		private final Assignment cKindAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cKindWide_string_typeEnumRuleCall_3_0 = (RuleCall)cKindAssignment_3.eContents().get(0);
		
		//charstr_type returns IDL::PrimitiveDef:
		//	kind=char_type | kind=wide_char_type | kind=string_type | kind=wide_string_type;
		public ParserRule getRule() { return rule; }

		//kind=char_type | kind=wide_char_type | kind=string_type | kind=wide_string_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//kind=char_type
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }

		//char_type
		public RuleCall getKindChar_typeEnumRuleCall_0_0() { return cKindChar_typeEnumRuleCall_0_0; }

		//kind=wide_char_type
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//wide_char_type
		public RuleCall getKindWide_char_typeEnumRuleCall_1_0() { return cKindWide_char_typeEnumRuleCall_1_0; }

		//kind=string_type
		public Assignment getKindAssignment_2() { return cKindAssignment_2; }

		//string_type
		public RuleCall getKindString_typeEnumRuleCall_2_0() { return cKindString_typeEnumRuleCall_2_0; }

		//kind=wide_string_type
		public Assignment getKindAssignment_3() { return cKindAssignment_3; }

		//wide_string_type
		public RuleCall getKindWide_string_typeEnumRuleCall_3_0() { return cKindWide_string_typeEnumRuleCall_3_0; }
	}

	public class Other_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "other_type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cKindAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cKindBoolean_typeEnumRuleCall_0_0 = (RuleCall)cKindAssignment_0.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cKindOctet_typeEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		private final Assignment cKindAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cKindAny_typeEnumRuleCall_2_0 = (RuleCall)cKindAssignment_2.eContents().get(0);
		
		//other_type returns IDL::PrimitiveDef:
		//	kind=boolean_type | kind=octet_type | kind=any_type;
		public ParserRule getRule() { return rule; }

		//kind=boolean_type | kind=octet_type | kind=any_type
		public Alternatives getAlternatives() { return cAlternatives; }

		//kind=boolean_type
		public Assignment getKindAssignment_0() { return cKindAssignment_0; }

		//boolean_type
		public RuleCall getKindBoolean_typeEnumRuleCall_0_0() { return cKindBoolean_typeEnumRuleCall_0_0; }

		//kind=octet_type
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//octet_type
		public RuleCall getKindOctet_typeEnumRuleCall_1_0() { return cKindOctet_typeEnumRuleCall_1_0; }

		//kind=any_type
		public Assignment getKindAssignment_2() { return cKindAssignment_2; }

		//any_type
		public RuleCall getKindAny_typeEnumRuleCall_2_0() { return cKindAny_typeEnumRuleCall_2_0; }
	}

	public class Fixed_pt_const_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fixed_pt_const_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFixedDefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFixedKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//fixed_pt_const_type returns IDL::FixedDef:
		//	{IDL::FixedDef} "fixed";
		public ParserRule getRule() { return rule; }

		//{IDL::FixedDef} "fixed"
		public Group getGroup() { return cGroup; }

		//{IDL::FixedDef}
		public Action getFixedDefAction_0() { return cFixedDefAction_0; }

		//"fixed"
		public Keyword getFixedKeyword_1() { return cFixedKeyword_1; }
	}

	public class Const_expElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "const_exp");
		private final RuleCall cOr_exprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////---------------------------
		//// CONST EXP
		////---------------------------
		//const_exp returns IDL::Expression:
		//	or_expr;
		public ParserRule getRule() { return rule; }

		//or_expr
		public RuleCall getOr_exprParserRuleCall() { return cOr_exprParserRuleCall; }
	}

	public class Or_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "or_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cXor_exprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorVerticalLineKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightXor_exprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//or_expr returns IDL::Expression:
		//	xor_expr ({IDL::BinaryExpression.left=current} operator="|" right=xor_expr)*;
		public ParserRule getRule() { return rule; }

		//xor_expr ({IDL::BinaryExpression.left=current} operator="|" right=xor_expr)*
		public Group getGroup() { return cGroup; }

		//xor_expr
		public RuleCall getXor_exprParserRuleCall_0() { return cXor_exprParserRuleCall_0; }

		//({IDL::BinaryExpression.left=current} operator="|" right=xor_expr)*
		public Group getGroup_1() { return cGroup_1; }

		//{IDL::BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }

		//operator="|"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"|"
		public Keyword getOperatorVerticalLineKeyword_1_1_0() { return cOperatorVerticalLineKeyword_1_1_0; }

		//right=xor_expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//xor_expr
		public RuleCall getRightXor_exprParserRuleCall_1_2_0() { return cRightXor_exprParserRuleCall_1_2_0; }
	}

	public class Xor_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "xor_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAnd_exprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorCircumflexAccentKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAnd_exprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//xor_expr returns IDL::Expression:
		//	and_expr ({IDL::BinaryExpression.left=current} operator="^" right=and_expr)*;
		public ParserRule getRule() { return rule; }

		//and_expr ({IDL::BinaryExpression.left=current} operator="^" right=and_expr)*
		public Group getGroup() { return cGroup; }

		//and_expr
		public RuleCall getAnd_exprParserRuleCall_0() { return cAnd_exprParserRuleCall_0; }

		//({IDL::BinaryExpression.left=current} operator="^" right=and_expr)*
		public Group getGroup_1() { return cGroup_1; }

		//{IDL::BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }

		//operator="^"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"^"
		public Keyword getOperatorCircumflexAccentKeyword_1_1_0() { return cOperatorCircumflexAccentKeyword_1_1_0; }

		//right=and_expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//and_expr
		public RuleCall getRightAnd_exprParserRuleCall_1_2_0() { return cRightAnd_exprParserRuleCall_1_2_0; }
	}

	public class And_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "and_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cShift_exprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Keyword cOperatorAmpersandKeyword_1_1_0 = (Keyword)cOperatorAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightShift_exprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//and_expr returns IDL::Expression:
		//	shift_expr ({IDL::BinaryExpression.left=current} operator="&" right=shift_expr)*;
		public ParserRule getRule() { return rule; }

		//shift_expr ({IDL::BinaryExpression.left=current} operator="&" right=shift_expr)*
		public Group getGroup() { return cGroup; }

		//shift_expr
		public RuleCall getShift_exprParserRuleCall_0() { return cShift_exprParserRuleCall_0; }

		//({IDL::BinaryExpression.left=current} operator="&" right=shift_expr)*
		public Group getGroup_1() { return cGroup_1; }

		//{IDL::BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }

		//operator="&"
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"&"
		public Keyword getOperatorAmpersandKeyword_1_1_0() { return cOperatorAmpersandKeyword_1_1_0; }

		//right=shift_expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//shift_expr
		public RuleCall getRightShift_exprParserRuleCall_1_2_0() { return cRightShift_exprParserRuleCall_1_2_0; }
	}

	public class Shift_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "shift_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdd_exprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorGreaterThanSignGreaterThanSignKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorLessThanSignLessThanSignKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAdd_exprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//shift_expr returns IDL::Expression:
		//	add_expr ({IDL::BinaryExpression.left=current} operator=(">>" | "<<") right=add_expr)*;
		public ParserRule getRule() { return rule; }

		//add_expr ({IDL::BinaryExpression.left=current} operator=(">>" | "<<") right=add_expr)*
		public Group getGroup() { return cGroup; }

		//add_expr
		public RuleCall getAdd_exprParserRuleCall_0() { return cAdd_exprParserRuleCall_0; }

		//({IDL::BinaryExpression.left=current} operator=(">>" | "<<") right=add_expr)*
		public Group getGroup_1() { return cGroup_1; }

		//{IDL::BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }

		//operator=(">>" | "<<")
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//">>" | "<<"
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }

		//">>"
		public Keyword getOperatorGreaterThanSignGreaterThanSignKeyword_1_1_0_0() { return cOperatorGreaterThanSignGreaterThanSignKeyword_1_1_0_0; }

		//"<<"
		public Keyword getOperatorLessThanSignLessThanSignKeyword_1_1_0_1() { return cOperatorLessThanSignLessThanSignKeyword_1_1_0_1; }

		//right=add_expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//add_expr
		public RuleCall getRightAdd_exprParserRuleCall_1_2_0() { return cRightAdd_exprParserRuleCall_1_2_0; }
	}

	public class Add_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "add_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMult_exprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorPlusSignKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorHyphenMinusKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMult_exprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//add_expr returns IDL::Expression:
		//	mult_expr ({IDL::BinaryExpression.left=current} operator=("+" | "-") right=mult_expr)*;
		public ParserRule getRule() { return rule; }

		//mult_expr ({IDL::BinaryExpression.left=current} operator=("+" | "-") right=mult_expr)*
		public Group getGroup() { return cGroup; }

		//mult_expr
		public RuleCall getMult_exprParserRuleCall_0() { return cMult_exprParserRuleCall_0; }

		//({IDL::BinaryExpression.left=current} operator=("+" | "-") right=mult_expr)*
		public Group getGroup_1() { return cGroup_1; }

		//{IDL::BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }

		//operator=("+" | "-")
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"+" | "-"
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }

		//"+"
		public Keyword getOperatorPlusSignKeyword_1_1_0_0() { return cOperatorPlusSignKeyword_1_1_0_0; }

		//"-"
		public Keyword getOperatorHyphenMinusKeyword_1_1_0_1() { return cOperatorHyphenMinusKeyword_1_1_0_1; }

		//right=mult_expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//mult_expr
		public RuleCall getRightMult_exprParserRuleCall_1_2_0() { return cRightMult_exprParserRuleCall_1_2_0; }
	}

	public class Mult_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "mult_expr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnary_exprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinaryExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperatorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOperatorAlternatives_1_1_0 = (Alternatives)cOperatorAssignment_1_1.eContents().get(0);
		private final Keyword cOperatorAsteriskKeyword_1_1_0_0 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOperatorSolidusKeyword_1_1_0_1 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(1);
		private final Keyword cOperatorPercentSignKeyword_1_1_0_2 = (Keyword)cOperatorAlternatives_1_1_0.eContents().get(2);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightUnary_exprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//mult_expr returns IDL::Expression:
		//	unary_expr ({IDL::BinaryExpression.left=current} operator=("*" | "/" | "%") right=unary_expr)*;
		public ParserRule getRule() { return rule; }

		//unary_expr ({IDL::BinaryExpression.left=current} operator=("*" | "/" | "%") right=unary_expr)*
		public Group getGroup() { return cGroup; }

		//unary_expr
		public RuleCall getUnary_exprParserRuleCall_0() { return cUnary_exprParserRuleCall_0; }

		//({IDL::BinaryExpression.left=current} operator=("*" | "/" | "%") right=unary_expr)*
		public Group getGroup_1() { return cGroup_1; }

		//{IDL::BinaryExpression.left=current}
		public Action getBinaryExpressionLeftAction_1_0() { return cBinaryExpressionLeftAction_1_0; }

		//operator=("*" | "/" | "%")
		public Assignment getOperatorAssignment_1_1() { return cOperatorAssignment_1_1; }

		//"*" | "/" | "%"
		public Alternatives getOperatorAlternatives_1_1_0() { return cOperatorAlternatives_1_1_0; }

		//"*"
		public Keyword getOperatorAsteriskKeyword_1_1_0_0() { return cOperatorAsteriskKeyword_1_1_0_0; }

		//"/"
		public Keyword getOperatorSolidusKeyword_1_1_0_1() { return cOperatorSolidusKeyword_1_1_0_1; }

		//"%"
		public Keyword getOperatorPercentSignKeyword_1_1_0_2() { return cOperatorPercentSignKeyword_1_1_0_2; }

		//right=unary_expr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//unary_expr
		public RuleCall getRightUnary_exprParserRuleCall_1_2_0() { return cRightUnary_exprParserRuleCall_1_2_0; }
	}

	public class Unary_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unary_expr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cUnaryExpressionAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cOperatorAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cOperatorUnary_operatorParserRuleCall_0_1_0 = (RuleCall)cOperatorAssignment_0_1.eContents().get(0);
		private final Assignment cExpressionAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExpressionPrimary_exprParserRuleCall_0_2_0 = (RuleCall)cExpressionAssignment_0_2.eContents().get(0);
		private final RuleCall cPrimary_exprParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//unary_expr returns IDL::Expression:
		//	{IDL::UnaryExpression} operator=unary_operator expression=primary_expr | primary_expr;
		public ParserRule getRule() { return rule; }

		//{IDL::UnaryExpression} operator=unary_operator expression=primary_expr | primary_expr
		public Alternatives getAlternatives() { return cAlternatives; }

		//{IDL::UnaryExpression} operator=unary_operator expression=primary_expr
		public Group getGroup_0() { return cGroup_0; }

		//{IDL::UnaryExpression}
		public Action getUnaryExpressionAction_0_0() { return cUnaryExpressionAction_0_0; }

		//operator=unary_operator
		public Assignment getOperatorAssignment_0_1() { return cOperatorAssignment_0_1; }

		//unary_operator
		public RuleCall getOperatorUnary_operatorParserRuleCall_0_1_0() { return cOperatorUnary_operatorParserRuleCall_0_1_0; }

		//expression=primary_expr
		public Assignment getExpressionAssignment_0_2() { return cExpressionAssignment_0_2; }

		//primary_expr
		public RuleCall getExpressionPrimary_exprParserRuleCall_0_2_0() { return cExpressionPrimary_exprParserRuleCall_0_2_0; }

		//primary_expr
		public RuleCall getPrimary_exprParserRuleCall_1() { return cPrimary_exprParserRuleCall_1; }
	}

	public class Unary_operatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "unary_operator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPlusSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cTildeKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		
		//unary_operator returns ecore::EString:
		//	"-" | "+" | "~";
		public ParserRule getRule() { return rule; }

		//"-" | "+" | "~"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"-"
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//"+"
		public Keyword getPlusSignKeyword_1() { return cPlusSignKeyword_1; }

		//"~"
		public Keyword getTildeKeyword_2() { return cTildeKeyword_2; }
	}

	public class Primary_exprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "primary_expr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantDefRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cValueExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cConst_expParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//primary_expr returns IDL::Expression: //ID
		//	constantDefRef | //literal
		//	valueExpression | "(" const_exp ")";
		public ParserRule getRule() { return rule; }

		////ID
		//constantDefRef | //literal
		//valueExpression | "(" const_exp ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		////ID
		//constantDefRef
		public RuleCall getConstantDefRefParserRuleCall_0() { return cConstantDefRefParserRuleCall_0; }

		////literal
		//valueExpression
		public RuleCall getValueExpressionParserRuleCall_1() { return cValueExpressionParserRuleCall_1; }

		//"(" const_exp ")"
		public Group getGroup_2() { return cGroup_2; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//const_exp
		public RuleCall getConst_expParserRuleCall_2_1() { return cConst_expParserRuleCall_2_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }
	}

	public class ConstantDefRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "constantDefRef");
		private final Assignment cConstantAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cConstantConstantCrossReference_0 = (CrossReference)cConstantAssignment.eContents().get(0);
		private final RuleCall cConstantConstantIDTerminalRuleCall_0_1 = (RuleCall)cConstantConstantCrossReference_0.eContents().get(1);
		
		//constantDefRef returns IDL::ConstantDefRef:
		//	constant=[IDL::Constant];
		public ParserRule getRule() { return rule; }

		//constant=[IDL::Constant]
		public Assignment getConstantAssignment() { return cConstantAssignment; }

		//[IDL::Constant]
		public CrossReference getConstantConstantCrossReference_0() { return cConstantConstantCrossReference_0; }

		//ID
		public RuleCall getConstantConstantIDTerminalRuleCall_0_1() { return cConstantConstantIDTerminalRuleCall_0_1; }
	}

	public class ValueExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "valueExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueLiteralParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//valueExpression returns IDL::ValueExpression:
		//	value=literal;
		public ParserRule getRule() { return rule; }

		//value=literal
		public Assignment getValueAssignment() { return cValueAssignment; }

		//literal
		public RuleCall getValueLiteralParserRuleCall_0() { return cValueLiteralParserRuleCall_0; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSTRINGTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cHEX_LITERALTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cWIDE_STRING_LITERALTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFIXED_PT_LITERALTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cFLOATING_PT_LITERALTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cBOOLEAN_LITERALTerminalRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//literal returns ecore::EString:
		//	INT / *|	INTEGER_LITERAL
		//	|	STRING_LITERAL* // *|	CHARACTER_LITERAL
		//	|	WIDE_CHARACTER_LITERAL* /| STRING | HEX_LITERAL | WIDE_STRING_LITERAL | FIXED_PT_LITERAL | FLOATING_PT_LITERAL |
		//	BOOLEAN_LITERAL;
		public ParserRule getRule() { return rule; }

		//INT / *|	INTEGER_LITERAL
		//	|	STRING_LITERAL* // *|	CHARACTER_LITERAL
		//	|	WIDE_CHARACTER_LITERAL* /| STRING | HEX_LITERAL | WIDE_STRING_LITERAL | FIXED_PT_LITERAL | FLOATING_PT_LITERAL |
		//BOOLEAN_LITERAL
		public Alternatives getAlternatives() { return cAlternatives; }

		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }

		//STRING
		public RuleCall getSTRINGTerminalRuleCall_1() { return cSTRINGTerminalRuleCall_1; }

		//HEX_LITERAL
		public RuleCall getHEX_LITERALTerminalRuleCall_2() { return cHEX_LITERALTerminalRuleCall_2; }

		//WIDE_STRING_LITERAL
		public RuleCall getWIDE_STRING_LITERALTerminalRuleCall_3() { return cWIDE_STRING_LITERALTerminalRuleCall_3; }

		//FIXED_PT_LITERAL
		public RuleCall getFIXED_PT_LITERALTerminalRuleCall_4() { return cFIXED_PT_LITERALTerminalRuleCall_4; }

		//FLOATING_PT_LITERAL
		public RuleCall getFLOATING_PT_LITERALTerminalRuleCall_5() { return cFLOATING_PT_LITERALTerminalRuleCall_5; }

		//BOOLEAN_LITERAL
		public RuleCall getBOOLEAN_LITERALTerminalRuleCall_6() { return cBOOLEAN_LITERALTerminalRuleCall_6; }
	}
	
	
	public class Param_attributeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "param_attribute");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPARAM_INEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPARAM_INInKeyword_0_0 = (Keyword)cPARAM_INEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPARAM_OUTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPARAM_OUTOutKeyword_1_0 = (Keyword)cPARAM_OUTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPARAM_INOUTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPARAM_INOUTInoutKeyword_2_0 = (Keyword)cPARAM_INOUTEnumLiteralDeclaration_2.eContents().get(0);
		
		////---------------------------
		//// PARAMETER MODES
		////---------------------------
		//enum param_attribute returns IDL::ParameterMode:
		//	PARAM_IN="in" | PARAM_OUT="out" | PARAM_INOUT="inout";
		public EnumRule getRule() { return rule; }

		//PARAM_IN="in" | PARAM_OUT="out" | PARAM_INOUT="inout"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PARAM_IN="in"
		public EnumLiteralDeclaration getPARAM_INEnumLiteralDeclaration_0() { return cPARAM_INEnumLiteralDeclaration_0; }

		//"in"
		public Keyword getPARAM_INInKeyword_0_0() { return cPARAM_INInKeyword_0_0; }

		//PARAM_OUT="out"
		public EnumLiteralDeclaration getPARAM_OUTEnumLiteralDeclaration_1() { return cPARAM_OUTEnumLiteralDeclaration_1; }

		//"out"
		public Keyword getPARAM_OUTOutKeyword_1_0() { return cPARAM_OUTOutKeyword_1_0; }

		//PARAM_INOUT="inout"
		public EnumLiteralDeclaration getPARAM_INOUTEnumLiteralDeclaration_2() { return cPARAM_INOUTEnumLiteralDeclaration_2; }

		//"inout"
		public Keyword getPARAM_INOUTInoutKeyword_2_0() { return cPARAM_INOUTInoutKeyword_2_0; }
	}

	public class Float_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "float_type");
		private final EnumLiteralDeclaration cPK_FLOATEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_FLOATFloatKeyword_0 = (Keyword)cPK_FLOATEnumLiteralDeclaration.eContents().get(0);
		
		//enum float_type returns IDL::PrimitiveKind:
		//	PK_FLOAT="float";
		public EnumRule getRule() { return rule; }

		//PK_FLOAT="float"
		public EnumLiteralDeclaration getPK_FLOATEnumLiteralDeclaration() { return cPK_FLOATEnumLiteralDeclaration; }

		//"float"
		public Keyword getPK_FLOATFloatKeyword_0() { return cPK_FLOATFloatKeyword_0; }
	}

	public class Double_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "double_type");
		private final EnumLiteralDeclaration cPK_DOUBLEEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_DOUBLEDoubleKeyword_0 = (Keyword)cPK_DOUBLEEnumLiteralDeclaration.eContents().get(0);
		
		//enum double_type returns IDL::PrimitiveKind:
		//	PK_DOUBLE="double";
		public EnumRule getRule() { return rule; }

		//PK_DOUBLE="double"
		public EnumLiteralDeclaration getPK_DOUBLEEnumLiteralDeclaration() { return cPK_DOUBLEEnumLiteralDeclaration; }

		//"double"
		public Keyword getPK_DOUBLEDoubleKeyword_0() { return cPK_DOUBLEDoubleKeyword_0; }
	}

	public class Short_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "short_type");
		private final EnumLiteralDeclaration cPK_SHORTEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_SHORTShortKeyword_0 = (Keyword)cPK_SHORTEnumLiteralDeclaration.eContents().get(0);
		
		//enum short_type returns IDL::PrimitiveKind:
		//	PK_SHORT="short";
		public EnumRule getRule() { return rule; }

		//PK_SHORT="short"
		public EnumLiteralDeclaration getPK_SHORTEnumLiteralDeclaration() { return cPK_SHORTEnumLiteralDeclaration; }

		//"short"
		public Keyword getPK_SHORTShortKeyword_0() { return cPK_SHORTShortKeyword_0; }
	}

	public class Long_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "long_type");
		private final EnumLiteralDeclaration cPK_LONGEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_LONGLongKeyword_0 = (Keyword)cPK_LONGEnumLiteralDeclaration.eContents().get(0);
		
		//enum long_type returns IDL::PrimitiveKind:
		//	PK_LONG="long";
		public EnumRule getRule() { return rule; }

		//PK_LONG="long"
		public EnumLiteralDeclaration getPK_LONGEnumLiteralDeclaration() { return cPK_LONGEnumLiteralDeclaration; }

		//"long"
		public Keyword getPK_LONGLongKeyword_0() { return cPK_LONGLongKeyword_0; }
	}

	public class Char_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "char_type");
		private final EnumLiteralDeclaration cPK_CHAREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_CHARCharKeyword_0 = (Keyword)cPK_CHAREnumLiteralDeclaration.eContents().get(0);
		
		//enum char_type returns IDL::PrimitiveKind:
		//	PK_CHAR="char";
		public EnumRule getRule() { return rule; }

		//PK_CHAR="char"
		public EnumLiteralDeclaration getPK_CHAREnumLiteralDeclaration() { return cPK_CHAREnumLiteralDeclaration; }

		//"char"
		public Keyword getPK_CHARCharKeyword_0() { return cPK_CHARCharKeyword_0; }
	}

	public class Wide_char_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "wide_char_type");
		private final EnumLiteralDeclaration cPK_WCHAREnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_WCHARWcharKeyword_0 = (Keyword)cPK_WCHAREnumLiteralDeclaration.eContents().get(0);
		
		//enum wide_char_type returns IDL::PrimitiveKind:
		//	PK_WCHAR="wchar";
		public EnumRule getRule() { return rule; }

		//PK_WCHAR="wchar"
		public EnumLiteralDeclaration getPK_WCHAREnumLiteralDeclaration() { return cPK_WCHAREnumLiteralDeclaration; }

		//"wchar"
		public Keyword getPK_WCHARWcharKeyword_0() { return cPK_WCHARWcharKeyword_0; }
	}

	public class String_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "string_type");
		private final EnumLiteralDeclaration cPK_STRINGEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_STRINGStringKeyword_0 = (Keyword)cPK_STRINGEnumLiteralDeclaration.eContents().get(0);
		
		//enum string_type returns IDL::PrimitiveKind:
		//	PK_STRING="string";
		public EnumRule getRule() { return rule; }

		//PK_STRING="string"
		public EnumLiteralDeclaration getPK_STRINGEnumLiteralDeclaration() { return cPK_STRINGEnumLiteralDeclaration; }

		//"string"
		public Keyword getPK_STRINGStringKeyword_0() { return cPK_STRINGStringKeyword_0; }
	}

	public class Wide_string_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "wide_string_type");
		private final EnumLiteralDeclaration cPK_WSTRINGEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_WSTRINGWstringKeyword_0 = (Keyword)cPK_WSTRINGEnumLiteralDeclaration.eContents().get(0);
		
		//enum wide_string_type returns IDL::PrimitiveKind:
		//	PK_WSTRING="wstring";
		public EnumRule getRule() { return rule; }

		//PK_WSTRING="wstring"
		public EnumLiteralDeclaration getPK_WSTRINGEnumLiteralDeclaration() { return cPK_WSTRINGEnumLiteralDeclaration; }

		//"wstring"
		public Keyword getPK_WSTRINGWstringKeyword_0() { return cPK_WSTRINGWstringKeyword_0; }
	}

	public class Boolean_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "boolean_type");
		private final EnumLiteralDeclaration cPK_BOOLEANEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_BOOLEANBooleanKeyword_0 = (Keyword)cPK_BOOLEANEnumLiteralDeclaration.eContents().get(0);
		
		//enum boolean_type returns IDL::PrimitiveKind:
		//	PK_BOOLEAN="boolean";
		public EnumRule getRule() { return rule; }

		//PK_BOOLEAN="boolean"
		public EnumLiteralDeclaration getPK_BOOLEANEnumLiteralDeclaration() { return cPK_BOOLEANEnumLiteralDeclaration; }

		//"boolean"
		public Keyword getPK_BOOLEANBooleanKeyword_0() { return cPK_BOOLEANBooleanKeyword_0; }
	}

	public class Octet_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "octet_type");
		private final EnumLiteralDeclaration cPK_OCTETEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_OCTETOctetKeyword_0 = (Keyword)cPK_OCTETEnumLiteralDeclaration.eContents().get(0);
		
		//enum octet_type returns IDL::PrimitiveKind:
		//	PK_OCTET="octet";
		public EnumRule getRule() { return rule; }

		//PK_OCTET="octet"
		public EnumLiteralDeclaration getPK_OCTETEnumLiteralDeclaration() { return cPK_OCTETEnumLiteralDeclaration; }

		//"octet"
		public Keyword getPK_OCTETOctetKeyword_0() { return cPK_OCTETOctetKeyword_0; }
	}

	public class Any_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "any_type");
		private final EnumLiteralDeclaration cPK_ANYEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_ANYAnyKeyword_0 = (Keyword)cPK_ANYEnumLiteralDeclaration.eContents().get(0);
		
		//enum any_type returns IDL::PrimitiveKind:
		//	PK_ANY="any";
		public EnumRule getRule() { return rule; }

		//PK_ANY="any"
		public EnumLiteralDeclaration getPK_ANYEnumLiteralDeclaration() { return cPK_ANYEnumLiteralDeclaration; }

		//"any"
		public Keyword getPK_ANYAnyKeyword_0() { return cPK_ANYAnyKeyword_0; }
	}

	public class Object_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "object_type");
		private final EnumLiteralDeclaration cPK_OBJREFEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_OBJREFObjectKeyword_0 = (Keyword)cPK_OBJREFEnumLiteralDeclaration.eContents().get(0);
		
		//enum object_type returns IDL::PrimitiveKind:
		//	PK_OBJREF="Object";
		public EnumRule getRule() { return rule; }

		//PK_OBJREF="Object"
		public EnumLiteralDeclaration getPK_OBJREFEnumLiteralDeclaration() { return cPK_OBJREFEnumLiteralDeclaration; }

		//"Object"
		public Keyword getPK_OBJREFObjectKeyword_0() { return cPK_OBJREFObjectKeyword_0; }
	}

	public class Void_typeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "void_type");
		private final EnumLiteralDeclaration cPK_VOIDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cPK_VOIDVoidKeyword_0 = (Keyword)cPK_VOIDEnumLiteralDeclaration.eContents().get(0);
		
		//enum void_type returns IDL::PrimitiveKind:
		//	PK_VOID="void";
		public EnumRule getRule() { return rule; }

		//PK_VOID="void"
		public EnumLiteralDeclaration getPK_VOIDEnumLiteralDeclaration() { return cPK_VOIDEnumLiteralDeclaration; }

		//"void"
		public Keyword getPK_VOIDVoidKeyword_0() { return cPK_VOIDVoidKeyword_0; }
	}
	
	private SpecificationElements pSpecification;
	private Include_declElements pInclude_decl;
	private DefinitionElements pDefinition;
	private ModuleElements pModule;
	private Interface_declElements pInterface_decl;
	private Interface_fwdElements pInterface_fwd;
	private ExportElements pExport;
	private Op_declElements pOp_decl;
	private Op_type_specElements pOp_type_spec;
	private Param_declElements pParam_decl;
	private Attr_declElements pAttr_decl;
	private Readonly_attr_specElements pReadonly_attr_spec;
	private Attr_specElements pAttr_spec;
	private Except_declElements pExcept_decl;
	private Type_declElements pType_decl;
	private Alias_typeElements pAlias_type;
	private Array_type_specElements pArray_type_spec;
	private Simple_type_specElements pSimple_type_spec;
	private Base_type_specElements pBase_type_spec;
	private Template_type_specElements pTemplate_type_spec;
	private Constr_type_specElements pConstr_type_spec;
	private Struct_typeElements pStruct_type;
	private MemberElements pMember;
	private Union_typeElements pUnion_type;
	private Switch_type_spec_contElements pSwitch_type_spec_cont;
	private Case_stmtElements pCase_stmt;
	private Enum_typeElements pEnum_type;
	private Enum_memberElements pEnum_member;
	private Constr_forward_declElements pConstr_forward_decl;
	private Const_declElements pConst_decl;
	private Const_typeElements pConst_type;
	private Primitive_defElements pPrimitive_def;
	private Sequence_typeElements pSequence_type;
	private Stringdef_typeElements pStringdef_type;
	private Wide_stringdef_typeElements pWide_stringdef_type;
	private Fixed_pt_typeElements pFixed_pt_type;
	private Param_attributeElements unknownRuleParam_attribute;
	private Floating_pt_typeElements pFloating_pt_type;
	private Float_typeElements unknownRuleFloat_type;
	private Double_typeElements unknownRuleDouble_type;
	private Longdouble_typeElements pLongdouble_type;
	private Integer_typeElements pInteger_type;
	private Short_typeElements unknownRuleShort_type;
	private Long_typeElements unknownRuleLong_type;
	private Longlong_typeElements pLonglong_type;
	private Ushort_typeElements pUshort_type;
	private Ulong_typeElements pUlong_type;
	private Ulonglong_typeElements pUlonglong_type;
	private Charstr_typeElements pCharstr_type;
	private Char_typeElements unknownRuleChar_type;
	private Wide_char_typeElements unknownRuleWide_char_type;
	private String_typeElements unknownRuleString_type;
	private Wide_string_typeElements unknownRuleWide_string_type;
	private Other_typeElements pOther_type;
	private Boolean_typeElements unknownRuleBoolean_type;
	private Octet_typeElements unknownRuleOctet_type;
	private Any_typeElements unknownRuleAny_type;
	private Object_typeElements unknownRuleObject_type;
	private Void_typeElements unknownRuleVoid_type;
	private Fixed_pt_const_typeElements pFixed_pt_const_type;
	private Const_expElements pConst_exp;
	private Or_exprElements pOr_expr;
	private Xor_exprElements pXor_expr;
	private And_exprElements pAnd_expr;
	private Shift_exprElements pShift_expr;
	private Add_exprElements pAdd_expr;
	private Mult_exprElements pMult_expr;
	private Unary_exprElements pUnary_expr;
	private Unary_operatorElements pUnary_operator;
	private Primary_exprElements pPrimary_expr;
	private ConstantDefRefElements pConstantDefRef;
	private ValueExpressionElements pValueExpression;
	private LiteralElements pLiteral;
	private TerminalRule tWIDE_STRING_LITERAL;
	private TerminalRule tFIXED_PT_LITERAL;
	private TerminalRule tFLOATING_PT_LITERAL;
	private TerminalRule tBOOLEAN_LITERAL;
	private TerminalRule tHEX_LITERAL;
	private TerminalRule tID;
	private TerminalRule tSTRING;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public IDLGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//specification returns IDL::TranslationUnit:
	//	{IDL::TranslationUnit} includes+=include_decl* contains+=definition*;
	public SpecificationElements getSpecificationAccess() {
		return (pSpecification != null) ? pSpecification : (pSpecification = new SpecificationElements());
	}
	
	public ParserRule getSpecificationRule() {
		return getSpecificationAccess().getRule();
	}

	//include_decl returns IDL::Include:
	//	"#include" importURI=STRING;
	public Include_declElements getInclude_declAccess() {
		return (pInclude_decl != null) ? pInclude_decl : (pInclude_decl = new Include_declElements());
	}
	
	public ParserRule getInclude_declRule() {
		return getInclude_declAccess().getRule();
	}

	////|	value ';'	//value pertenece a corba 2.3
	////|	type_id_decl ';'
	////|	type_prefix_decl ';'
	////|	event ';'
	////|	component ';'
	////|	home_decl ';'
	//definition returns IDL::Contained:
	//	type_decl ";" | const_decl ";" | except_decl ";" | interface_decl ";" | interface_fwd ";" | module ";";
	public DefinitionElements getDefinitionAccess() {
		return (pDefinition != null) ? pDefinition : (pDefinition = new DefinitionElements());
	}
	
	public ParserRule getDefinitionRule() {
		return getDefinitionAccess().getRule();
	}

	//module returns IDL::ModuleDef:
	//	"module" identifier=ID "{" (contains+=definition | ";")* "}";
	public ModuleElements getModuleAccess() {
		return (pModule != null) ? pModule : (pModule = new ModuleElements());
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}

	//interface_decl returns IDL::InterfaceDef:
	//	(isAbstract?="abstract" | isCustom?="local")? "interface" identifier=ID (":" derivesFrom+=[IDL::InterfaceDef] (","
	//	derivesFrom+=[IDL::InterfaceDef])*)? "{" (contains+=export | ";")* "}";
	public Interface_declElements getInterface_declAccess() {
		return (pInterface_decl != null) ? pInterface_decl : (pInterface_decl = new Interface_declElements());
	}
	
	public ParserRule getInterface_declRule() {
		return getInterface_declAccess().getRule();
	}

	//interface_fwd returns IDL::ForwardDef:
	//	("abstract" | "local")? "interface" identifier=ID;
	public Interface_fwdElements getInterface_fwdAccess() {
		return (pInterface_fwd != null) ? pInterface_fwd : (pInterface_fwd = new Interface_fwdElements());
	}
	
	public ParserRule getInterface_fwdRule() {
		return getInterface_fwdAccess().getRule();
	}

	////	|	type_id_decl ';'
	////	|	type_prefix_decl ';'
	//export returns IDL::Contained:
	//	type_decl ";" | const_decl ";" | except_decl ";" | attr_decl ";" | op_decl ";";
	public ExportElements getExportAccess() {
		return (pExport != null) ? pExport : (pExport = new ExportElements());
	}
	
	public ParserRule getExportRule() {
		return getExportAccess().getRule();
	}

	//op_decl returns IDL::OperationDef:
	//	isOneway?="oneway"? (containedType=op_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID "("
	//	(parameters+=param_decl ("," parameters+=param_decl)*)? ")" ("raises" "(" canRaise+=[IDL::ExceptionDef] (","
	//	canRaise+=[IDL::ExceptionDef])* ")")? ("context" "(" contexts+=STRING ("," contexts+=STRING)* ")")?;
	public Op_declElements getOp_declAccess() {
		return (pOp_decl != null) ? pOp_decl : (pOp_decl = new Op_declElements());
	}
	
	public ParserRule getOp_declRule() {
		return getOp_declAccess().getRule();
	}

	//op_type_spec returns IDL::IDLType:
	//	base_type_spec | {IDL::PrimitiveDef} kind=void_type;
	public Op_type_specElements getOp_type_specAccess() {
		return (pOp_type_spec != null) ? pOp_type_spec : (pOp_type_spec = new Op_type_specElements());
	}
	
	public ParserRule getOp_type_specRule() {
		return getOp_type_specAccess().getRule();
	}

	//param_decl returns IDL::ParameterDef:
	//	direction=param_attribute (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID;
	public Param_declElements getParam_declAccess() {
		return (pParam_decl != null) ? pParam_decl : (pParam_decl = new Param_declElements());
	}
	
	public ParserRule getParam_declRule() {
		return getParam_declAccess().getRule();
	}

	//attr_decl returns IDL::AttributeDef:
	//	readonly_attr_spec | attr_spec;
	public Attr_declElements getAttr_declAccess() {
		return (pAttr_decl != null) ? pAttr_decl : (pAttr_decl = new Attr_declElements());
	}
	
	public ParserRule getAttr_declRule() {
		return getAttr_declAccess().getRule();
	}

	//readonly_attr_spec returns IDL::AttributeDef:
	//	isReadonly?="readonly" "attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID
	//	"raises" "(" getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" | isReadonly?="readonly"
	//	"attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID;
	public Readonly_attr_specElements getReadonly_attr_specAccess() {
		return (pReadonly_attr_spec != null) ? pReadonly_attr_spec : (pReadonly_attr_spec = new Readonly_attr_specElements());
	}
	
	public ParserRule getReadonly_attr_specRule() {
		return getReadonly_attr_specAccess().getRule();
	}

	//attr_spec returns IDL::AttributeDef:
	//	"attribute" (containedType=base_type_spec | sharedType=[IDL::TypedefDef]) identifier=ID ("getraises" "("
	//	getRaises+=[IDL::ExceptionDef] ("," getRaises+=[IDL::ExceptionDef])* ")" ("setraises" "("
	//	setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")")? | "setraises" "("
	//	setRaises+=[IDL::ExceptionDef] ("," setRaises+=[IDL::ExceptionDef])* ")") | "attribute" (containedType=base_type_spec
	//	| sharedType=[IDL::TypedefDef]) identifier=ID;
	public Attr_specElements getAttr_specAccess() {
		return (pAttr_spec != null) ? pAttr_spec : (pAttr_spec = new Attr_specElements());
	}
	
	public ParserRule getAttr_specRule() {
		return getAttr_specAccess().getRule();
	}

	//except_decl returns IDL::ExceptionDef:
	//	"exception" identifier=ID "{" members+=member* "}";
	public Except_declElements getExcept_declAccess() {
		return (pExcept_decl != null) ? pExcept_decl : (pExcept_decl = new Except_declElements());
	}
	
	public ParserRule getExcept_declRule() {
		return getExcept_declAccess().getRule();
	}

	//type_decl returns IDL::TypedefDef:
	//	alias_type | struct_type | union_type | enum_type | "native" ID | constr_forward_decl;
	public Type_declElements getType_declAccess() {
		return (pType_decl != null) ? pType_decl : (pType_decl = new Type_declElements());
	}
	
	public ParserRule getType_declRule() {
		return getType_declAccess().getRule();
	}

	//alias_type returns IDL::AliasDef:
	//	"typedef" containedType=array_type_spec | "typedef" (containedType=simple_type_spec | sharedType=[IDL::TypedefDef])
	//	identifier=ID;
	public Alias_typeElements getAlias_typeAccess() {
		return (pAlias_type != null) ? pAlias_type : (pAlias_type = new Alias_typeElements());
	}
	
	public ParserRule getAlias_typeRule() {
		return getAlias_typeAccess().getRule();
	}

	/// *id_array
	//	:	ID ('['const_exp']')+
	//	;* /array_type_spec returns IDL::ArrayDef:
	//	(containedType=simple_type_spec | sharedType=[IDL::TypedefDef]) name=ID ("[" bounds+=const_exp "]")+;
	public Array_type_specElements getArray_type_specAccess() {
		return (pArray_type_spec != null) ? pArray_type_spec : (pArray_type_spec = new Array_type_specElements());
	}
	
	public ParserRule getArray_type_specRule() {
		return getArray_type_specAccess().getRule();
	}

	//simple_type_spec returns IDL::IDLType:
	//	base_type_spec | template_type_spec;
	public Simple_type_specElements getSimple_type_specAccess() {
		return (pSimple_type_spec != null) ? pSimple_type_spec : (pSimple_type_spec = new Simple_type_specElements());
	}
	
	public ParserRule getSimple_type_specRule() {
		return getSimple_type_specAccess().getRule();
	}

	//base_type_spec returns IDL::PrimitiveDef:
	//	primitive_def | kind=object_type;
	public Base_type_specElements getBase_type_specAccess() {
		return (pBase_type_spec != null) ? pBase_type_spec : (pBase_type_spec = new Base_type_specElements());
	}
	
	public ParserRule getBase_type_specRule() {
		return getBase_type_specAccess().getRule();
	}

	//template_type_spec returns IDL::IDLType:
	//	sequence_type | stringdef_type | wide_stringdef_type | fixed_pt_type;
	public Template_type_specElements getTemplate_type_specAccess() {
		return (pTemplate_type_spec != null) ? pTemplate_type_spec : (pTemplate_type_spec = new Template_type_specElements());
	}
	
	public ParserRule getTemplate_type_specRule() {
		return getTemplate_type_specAccess().getRule();
	}

	//constr_type_spec returns IDL::TypedefDef:
	//	struct_type | union_type | enum_type;
	public Constr_type_specElements getConstr_type_specAccess() {
		return (pConstr_type_spec != null) ? pConstr_type_spec : (pConstr_type_spec = new Constr_type_specElements());
	}
	
	public ParserRule getConstr_type_specRule() {
		return getConstr_type_specAccess().getRule();
	}

	//struct_type returns IDL::StructDef:
	//	"struct" identifier=ID "{" members+=member+ "}";
	public Struct_typeElements getStruct_typeAccess() {
		return (pStruct_type != null) ? pStruct_type : (pStruct_type = new Struct_typeElements());
	}
	
	public ParserRule getStruct_typeRule() {
		return getStruct_typeAccess().getRule();
	}

	//member returns IDL::Field:
	//	containedType=array_type_spec / *identifier= id_array* / ";" | containedType=simple_type_spec identifier=ID ";" |
	//	containedType=struct_type identifier=ID ";" | sharedType=[IDL::TypedefDef] identifier=ID ";";
	public MemberElements getMemberAccess() {
		return (pMember != null) ? pMember : (pMember = new MemberElements());
	}
	
	public ParserRule getMemberRule() {
		return getMemberAccess().getRule();
	}

	//union_type returns IDL::UnionDef:
	//	"union" identifier=ID "switch" "(" (containedDiscrim=switch_type_spec_cont | sharedDiscrim=[IDL::EnumDef]) ")" "{"
	//	unionMembers+=case_stmt+ "}";
	public Union_typeElements getUnion_typeAccess() {
		return (pUnion_type != null) ? pUnion_type : (pUnion_type = new Union_typeElements());
	}
	
	public ParserRule getUnion_typeRule() {
		return getUnion_typeAccess().getRule();
	}

	//switch_type_spec_cont returns IDL::IDLType:
	//	integer_type | {IDL::PrimitiveDef} kind=char_type | {IDL::PrimitiveDef} kind=boolean_type | enum_type;
	public Switch_type_spec_contElements getSwitch_type_spec_contAccess() {
		return (pSwitch_type_spec_cont != null) ? pSwitch_type_spec_cont : (pSwitch_type_spec_cont = new Switch_type_spec_contElements());
	}
	
	public ParserRule getSwitch_type_spec_contRule() {
		return getSwitch_type_spec_contAccess().getRule();
	}

	//case_stmt returns IDL::UnionField:
	//	("case" label+=const_exp ":" | / *label+=* / "default" ":")+ containedType=array_type_spec / *identifier= id_array* / ";"
	//	| ("case" label+=const_exp ":" | / *label+=* / "default" ":")+ (containedType=simple_type_spec |
	//	sharedType=[IDL::TypedefDef]) identifier=ID ";";
	public Case_stmtElements getCase_stmtAccess() {
		return (pCase_stmt != null) ? pCase_stmt : (pCase_stmt = new Case_stmtElements());
	}
	
	public ParserRule getCase_stmtRule() {
		return getCase_stmtAccess().getRule();
	}

	//enum_type returns IDL::EnumDef:
	//	"enum" identifier=ID "{" members+=enum_member ("," members+=enum_member)* "}";
	public Enum_typeElements getEnum_typeAccess() {
		return (pEnum_type != null) ? pEnum_type : (pEnum_type = new Enum_typeElements());
	}
	
	public ParserRule getEnum_typeRule() {
		return getEnum_typeAccess().getRule();
	}

	//enum_member returns IDL::EnumMember:
	//	identifier=ID;
	public Enum_memberElements getEnum_memberAccess() {
		return (pEnum_member != null) ? pEnum_member : (pEnum_member = new Enum_memberElements());
	}
	
	public ParserRule getEnum_memberRule() {
		return getEnum_memberAccess().getRule();
	}

	//constr_forward_decl returns ecore::EString:
	//	"struct" ID | "union" ID;
	public Constr_forward_declElements getConstr_forward_declAccess() {
		return (pConstr_forward_decl != null) ? pConstr_forward_decl : (pConstr_forward_decl = new Constr_forward_declElements());
	}
	
	public ParserRule getConstr_forward_declRule() {
		return getConstr_forward_declAccess().getRule();
	}

	//// FIXME: las constantes de tipo FixedDef tienen un value distinto (no const_exp) 12.34D
	//// TODO: implementar plantilla xtend para completar los datos de los elementos containedType
	////       como por ejemplo el fixedDef y sus campos parte real y parte flotante
	//// TODO: comprobar con xtend o cheq que el sharedType es un alias de un tipo básico!!
	//const_decl returns IDL::ConstantDef:
	//	"const" (containedType=const_type | sharedType=[IDL::AliasDef]) identifier=ID "=" constValue=const_exp;
	public Const_declElements getConst_declAccess() {
		return (pConst_decl != null) ? pConst_decl : (pConst_decl = new Const_declElements());
	}
	
	public ParserRule getConst_declRule() {
		return getConst_declAccess().getRule();
	}

	//const_type returns IDL::IDLType:
	//	primitive_def | stringdef_type | wide_stringdef_type | fixed_pt_const_type;
	public Const_typeElements getConst_typeAccess() {
		return (pConst_type != null) ? pConst_type : (pConst_type = new Const_typeElements());
	}
	
	public ParserRule getConst_typeRule() {
		return getConst_typeAccess().getRule();
	}

	//primitive_def returns IDL::PrimitiveDef:
	//	integer_type | floating_pt_type | charstr_type | other_type;
	public Primitive_defElements getPrimitive_defAccess() {
		return (pPrimitive_def != null) ? pPrimitive_def : (pPrimitive_def = new Primitive_defElements());
	}
	
	public ParserRule getPrimitive_defRule() {
		return getPrimitive_defAccess().getRule();
	}

	////----------------------------
	////		DECLARATORS
	////----------------------------
	/// *
	//declarators
	//	:	declarator ( ',' declarator )*
	//	;
	//
	//simple_declarators
	//	:	(simple_declarator (',' simple_declarator)*)
	//	;
	//
	//declarator
	//	:	simple_declarator
	//	|	complex_declarator
	//	;
	//
	//simple_declarator
	//	:	ID
	//	;
	//
	//// TODO: añadir el arraydef!!!
	//complex_declarator
	//	:	ID ('[' const_exp ']')+
	//	;
	// * ///---------------------------
	//// TEMPLATE TYPES
	////---------------------------
	//sequence_type returns IDL::SequenceDef:
	//	"sequence" "<" (containedType=simple_type_spec | sharedType=[IDL::TypedefDef]) ("," bound=const_exp)? ">";
	public Sequence_typeElements getSequence_typeAccess() {
		return (pSequence_type != null) ? pSequence_type : (pSequence_type = new Sequence_typeElements());
	}
	
	public ParserRule getSequence_typeRule() {
		return getSequence_typeAccess().getRule();
	}

	//stringdef_type returns IDL::StringDef:
	//	"string" "<" bound=const_exp ">";
	public Stringdef_typeElements getStringdef_typeAccess() {
		return (pStringdef_type != null) ? pStringdef_type : (pStringdef_type = new Stringdef_typeElements());
	}
	
	public ParserRule getStringdef_typeRule() {
		return getStringdef_typeAccess().getRule();
	}

	//wide_stringdef_type returns IDL::WstringDef:
	//	"wstring" "<" bound=const_exp ">";
	public Wide_stringdef_typeElements getWide_stringdef_typeAccess() {
		return (pWide_stringdef_type != null) ? pWide_stringdef_type : (pWide_stringdef_type = new Wide_stringdef_typeElements());
	}
	
	public ParserRule getWide_stringdef_typeRule() {
		return getWide_stringdef_typeAccess().getRule();
	}

	//fixed_pt_type returns IDL::FixedDef:
	//	"fixed" "<" digits=const_exp "," scale=const_exp ">";
	public Fixed_pt_typeElements getFixed_pt_typeAccess() {
		return (pFixed_pt_type != null) ? pFixed_pt_type : (pFixed_pt_type = new Fixed_pt_typeElements());
	}
	
	public ParserRule getFixed_pt_typeRule() {
		return getFixed_pt_typeAccess().getRule();
	}

	////---------------------------
	//// PARAMETER MODES
	////---------------------------
	//enum param_attribute returns IDL::ParameterMode:
	//	PARAM_IN="in" | PARAM_OUT="out" | PARAM_INOUT="inout";
	public Param_attributeElements getParam_attributeAccess() {
		return (unknownRuleParam_attribute != null) ? unknownRuleParam_attribute : (unknownRuleParam_attribute = new Param_attributeElements());
	}
	
	public EnumRule getParam_attributeRule() {
		return getParam_attributeAccess().getRule();
	}

	////---------------------------
	//// BASE TYPES
	////---------------------------
	//floating_pt_type returns IDL::PrimitiveDef:
	//	kind=float_type | kind=double_type | kind=longdouble_type;
	public Floating_pt_typeElements getFloating_pt_typeAccess() {
		return (pFloating_pt_type != null) ? pFloating_pt_type : (pFloating_pt_type = new Floating_pt_typeElements());
	}
	
	public ParserRule getFloating_pt_typeRule() {
		return getFloating_pt_typeAccess().getRule();
	}

	//enum float_type returns IDL::PrimitiveKind:
	//	PK_FLOAT="float";
	public Float_typeElements getFloat_typeAccess() {
		return (unknownRuleFloat_type != null) ? unknownRuleFloat_type : (unknownRuleFloat_type = new Float_typeElements());
	}
	
	public EnumRule getFloat_typeRule() {
		return getFloat_typeAccess().getRule();
	}

	//enum double_type returns IDL::PrimitiveKind:
	//	PK_DOUBLE="double";
	public Double_typeElements getDouble_typeAccess() {
		return (unknownRuleDouble_type != null) ? unknownRuleDouble_type : (unknownRuleDouble_type = new Double_typeElements());
	}
	
	public EnumRule getDouble_typeRule() {
		return getDouble_typeAccess().getRule();
	}

	//longdouble_type returns IDL::PrimitiveKind:
	//	"long" "double";
	public Longdouble_typeElements getLongdouble_typeAccess() {
		return (pLongdouble_type != null) ? pLongdouble_type : (pLongdouble_type = new Longdouble_typeElements());
	}
	
	public ParserRule getLongdouble_typeRule() {
		return getLongdouble_typeAccess().getRule();
	}

	//integer_type returns IDL::PrimitiveDef:
	//	kind=short_type | kind=long_type | kind=longlong_type | kind=ushort_type | kind=ulong_type | kind=ulonglong_type;
	public Integer_typeElements getInteger_typeAccess() {
		return (pInteger_type != null) ? pInteger_type : (pInteger_type = new Integer_typeElements());
	}
	
	public ParserRule getInteger_typeRule() {
		return getInteger_typeAccess().getRule();
	}

	//enum short_type returns IDL::PrimitiveKind:
	//	PK_SHORT="short";
	public Short_typeElements getShort_typeAccess() {
		return (unknownRuleShort_type != null) ? unknownRuleShort_type : (unknownRuleShort_type = new Short_typeElements());
	}
	
	public EnumRule getShort_typeRule() {
		return getShort_typeAccess().getRule();
	}

	//enum long_type returns IDL::PrimitiveKind:
	//	PK_LONG="long";
	public Long_typeElements getLong_typeAccess() {
		return (unknownRuleLong_type != null) ? unknownRuleLong_type : (unknownRuleLong_type = new Long_typeElements());
	}
	
	public EnumRule getLong_typeRule() {
		return getLong_typeAccess().getRule();
	}

	//longlong_type returns IDL::PrimitiveKind:
	//	"long" "long";
	public Longlong_typeElements getLonglong_typeAccess() {
		return (pLonglong_type != null) ? pLonglong_type : (pLonglong_type = new Longlong_typeElements());
	}
	
	public ParserRule getLonglong_typeRule() {
		return getLonglong_typeAccess().getRule();
	}

	//ushort_type returns IDL::PrimitiveKind:
	//	"unsigned" "short";
	public Ushort_typeElements getUshort_typeAccess() {
		return (pUshort_type != null) ? pUshort_type : (pUshort_type = new Ushort_typeElements());
	}
	
	public ParserRule getUshort_typeRule() {
		return getUshort_typeAccess().getRule();
	}

	//ulong_type returns IDL::PrimitiveKind:
	//	"unsigned" "long";
	public Ulong_typeElements getUlong_typeAccess() {
		return (pUlong_type != null) ? pUlong_type : (pUlong_type = new Ulong_typeElements());
	}
	
	public ParserRule getUlong_typeRule() {
		return getUlong_typeAccess().getRule();
	}

	//ulonglong_type returns IDL::PrimitiveKind:
	//	"unsigned" "long" "long";
	public Ulonglong_typeElements getUlonglong_typeAccess() {
		return (pUlonglong_type != null) ? pUlonglong_type : (pUlonglong_type = new Ulonglong_typeElements());
	}
	
	public ParserRule getUlonglong_typeRule() {
		return getUlonglong_typeAccess().getRule();
	}

	//charstr_type returns IDL::PrimitiveDef:
	//	kind=char_type | kind=wide_char_type | kind=string_type | kind=wide_string_type;
	public Charstr_typeElements getCharstr_typeAccess() {
		return (pCharstr_type != null) ? pCharstr_type : (pCharstr_type = new Charstr_typeElements());
	}
	
	public ParserRule getCharstr_typeRule() {
		return getCharstr_typeAccess().getRule();
	}

	//enum char_type returns IDL::PrimitiveKind:
	//	PK_CHAR="char";
	public Char_typeElements getChar_typeAccess() {
		return (unknownRuleChar_type != null) ? unknownRuleChar_type : (unknownRuleChar_type = new Char_typeElements());
	}
	
	public EnumRule getChar_typeRule() {
		return getChar_typeAccess().getRule();
	}

	//enum wide_char_type returns IDL::PrimitiveKind:
	//	PK_WCHAR="wchar";
	public Wide_char_typeElements getWide_char_typeAccess() {
		return (unknownRuleWide_char_type != null) ? unknownRuleWide_char_type : (unknownRuleWide_char_type = new Wide_char_typeElements());
	}
	
	public EnumRule getWide_char_typeRule() {
		return getWide_char_typeAccess().getRule();
	}

	//enum string_type returns IDL::PrimitiveKind:
	//	PK_STRING="string";
	public String_typeElements getString_typeAccess() {
		return (unknownRuleString_type != null) ? unknownRuleString_type : (unknownRuleString_type = new String_typeElements());
	}
	
	public EnumRule getString_typeRule() {
		return getString_typeAccess().getRule();
	}

	//enum wide_string_type returns IDL::PrimitiveKind:
	//	PK_WSTRING="wstring";
	public Wide_string_typeElements getWide_string_typeAccess() {
		return (unknownRuleWide_string_type != null) ? unknownRuleWide_string_type : (unknownRuleWide_string_type = new Wide_string_typeElements());
	}
	
	public EnumRule getWide_string_typeRule() {
		return getWide_string_typeAccess().getRule();
	}

	//other_type returns IDL::PrimitiveDef:
	//	kind=boolean_type | kind=octet_type | kind=any_type;
	public Other_typeElements getOther_typeAccess() {
		return (pOther_type != null) ? pOther_type : (pOther_type = new Other_typeElements());
	}
	
	public ParserRule getOther_typeRule() {
		return getOther_typeAccess().getRule();
	}

	//enum boolean_type returns IDL::PrimitiveKind:
	//	PK_BOOLEAN="boolean";
	public Boolean_typeElements getBoolean_typeAccess() {
		return (unknownRuleBoolean_type != null) ? unknownRuleBoolean_type : (unknownRuleBoolean_type = new Boolean_typeElements());
	}
	
	public EnumRule getBoolean_typeRule() {
		return getBoolean_typeAccess().getRule();
	}

	//enum octet_type returns IDL::PrimitiveKind:
	//	PK_OCTET="octet";
	public Octet_typeElements getOctet_typeAccess() {
		return (unknownRuleOctet_type != null) ? unknownRuleOctet_type : (unknownRuleOctet_type = new Octet_typeElements());
	}
	
	public EnumRule getOctet_typeRule() {
		return getOctet_typeAccess().getRule();
	}

	//enum any_type returns IDL::PrimitiveKind:
	//	PK_ANY="any";
	public Any_typeElements getAny_typeAccess() {
		return (unknownRuleAny_type != null) ? unknownRuleAny_type : (unknownRuleAny_type = new Any_typeElements());
	}
	
	public EnumRule getAny_typeRule() {
		return getAny_typeAccess().getRule();
	}

	//enum object_type returns IDL::PrimitiveKind:
	//	PK_OBJREF="Object";
	public Object_typeElements getObject_typeAccess() {
		return (unknownRuleObject_type != null) ? unknownRuleObject_type : (unknownRuleObject_type = new Object_typeElements());
	}
	
	public EnumRule getObject_typeRule() {
		return getObject_typeAccess().getRule();
	}

	//enum void_type returns IDL::PrimitiveKind:
	//	PK_VOID="void";
	public Void_typeElements getVoid_typeAccess() {
		return (unknownRuleVoid_type != null) ? unknownRuleVoid_type : (unknownRuleVoid_type = new Void_typeElements());
	}
	
	public EnumRule getVoid_typeRule() {
		return getVoid_typeAccess().getRule();
	}

	//fixed_pt_const_type returns IDL::FixedDef:
	//	{IDL::FixedDef} "fixed";
	public Fixed_pt_const_typeElements getFixed_pt_const_typeAccess() {
		return (pFixed_pt_const_type != null) ? pFixed_pt_const_type : (pFixed_pt_const_type = new Fixed_pt_const_typeElements());
	}
	
	public ParserRule getFixed_pt_const_typeRule() {
		return getFixed_pt_const_typeAccess().getRule();
	}

	////---------------------------
	//// CONST EXP
	////---------------------------
	//const_exp returns IDL::Expression:
	//	or_expr;
	public Const_expElements getConst_expAccess() {
		return (pConst_exp != null) ? pConst_exp : (pConst_exp = new Const_expElements());
	}
	
	public ParserRule getConst_expRule() {
		return getConst_expAccess().getRule();
	}

	//or_expr returns IDL::Expression:
	//	xor_expr ({IDL::BinaryExpression.left=current} operator="|" right=xor_expr)*;
	public Or_exprElements getOr_exprAccess() {
		return (pOr_expr != null) ? pOr_expr : (pOr_expr = new Or_exprElements());
	}
	
	public ParserRule getOr_exprRule() {
		return getOr_exprAccess().getRule();
	}

	//xor_expr returns IDL::Expression:
	//	and_expr ({IDL::BinaryExpression.left=current} operator="^" right=and_expr)*;
	public Xor_exprElements getXor_exprAccess() {
		return (pXor_expr != null) ? pXor_expr : (pXor_expr = new Xor_exprElements());
	}
	
	public ParserRule getXor_exprRule() {
		return getXor_exprAccess().getRule();
	}

	//and_expr returns IDL::Expression:
	//	shift_expr ({IDL::BinaryExpression.left=current} operator="&" right=shift_expr)*;
	public And_exprElements getAnd_exprAccess() {
		return (pAnd_expr != null) ? pAnd_expr : (pAnd_expr = new And_exprElements());
	}
	
	public ParserRule getAnd_exprRule() {
		return getAnd_exprAccess().getRule();
	}

	//shift_expr returns IDL::Expression:
	//	add_expr ({IDL::BinaryExpression.left=current} operator=(">>" | "<<") right=add_expr)*;
	public Shift_exprElements getShift_exprAccess() {
		return (pShift_expr != null) ? pShift_expr : (pShift_expr = new Shift_exprElements());
	}
	
	public ParserRule getShift_exprRule() {
		return getShift_exprAccess().getRule();
	}

	//add_expr returns IDL::Expression:
	//	mult_expr ({IDL::BinaryExpression.left=current} operator=("+" | "-") right=mult_expr)*;
	public Add_exprElements getAdd_exprAccess() {
		return (pAdd_expr != null) ? pAdd_expr : (pAdd_expr = new Add_exprElements());
	}
	
	public ParserRule getAdd_exprRule() {
		return getAdd_exprAccess().getRule();
	}

	//mult_expr returns IDL::Expression:
	//	unary_expr ({IDL::BinaryExpression.left=current} operator=("*" | "/" | "%") right=unary_expr)*;
	public Mult_exprElements getMult_exprAccess() {
		return (pMult_expr != null) ? pMult_expr : (pMult_expr = new Mult_exprElements());
	}
	
	public ParserRule getMult_exprRule() {
		return getMult_exprAccess().getRule();
	}

	//unary_expr returns IDL::Expression:
	//	{IDL::UnaryExpression} operator=unary_operator expression=primary_expr | primary_expr;
	public Unary_exprElements getUnary_exprAccess() {
		return (pUnary_expr != null) ? pUnary_expr : (pUnary_expr = new Unary_exprElements());
	}
	
	public ParserRule getUnary_exprRule() {
		return getUnary_exprAccess().getRule();
	}

	//unary_operator returns ecore::EString:
	//	"-" | "+" | "~";
	public Unary_operatorElements getUnary_operatorAccess() {
		return (pUnary_operator != null) ? pUnary_operator : (pUnary_operator = new Unary_operatorElements());
	}
	
	public ParserRule getUnary_operatorRule() {
		return getUnary_operatorAccess().getRule();
	}

	//primary_expr returns IDL::Expression: //ID
	//	constantDefRef | //literal
	//	valueExpression | "(" const_exp ")";
	public Primary_exprElements getPrimary_exprAccess() {
		return (pPrimary_expr != null) ? pPrimary_expr : (pPrimary_expr = new Primary_exprElements());
	}
	
	public ParserRule getPrimary_exprRule() {
		return getPrimary_exprAccess().getRule();
	}

	//constantDefRef returns IDL::ConstantDefRef:
	//	constant=[IDL::Constant];
	public ConstantDefRefElements getConstantDefRefAccess() {
		return (pConstantDefRef != null) ? pConstantDefRef : (pConstantDefRef = new ConstantDefRefElements());
	}
	
	public ParserRule getConstantDefRefRule() {
		return getConstantDefRefAccess().getRule();
	}

	//valueExpression returns IDL::ValueExpression:
	//	value=literal;
	public ValueExpressionElements getValueExpressionAccess() {
		return (pValueExpression != null) ? pValueExpression : (pValueExpression = new ValueExpressionElements());
	}
	
	public ParserRule getValueExpressionRule() {
		return getValueExpressionAccess().getRule();
	}

	//literal returns ecore::EString:
	//	INT / *|	INTEGER_LITERAL
	//	|	STRING_LITERAL* // *|	CHARACTER_LITERAL
	//	|	WIDE_CHARACTER_LITERAL* /| STRING | HEX_LITERAL | WIDE_STRING_LITERAL | FIXED_PT_LITERAL | FLOATING_PT_LITERAL |
	//	BOOLEAN_LITERAL;
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//terminal WIDE_STRING_LITERAL:
	//	"L" STRING;
	public TerminalRule getWIDE_STRING_LITERALRule() {
		return (tWIDE_STRING_LITERAL != null) ? tWIDE_STRING_LITERAL : (tWIDE_STRING_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WIDE_STRING_LITERAL"));
	} 

	//terminal FIXED_PT_LITERAL:
	//	INT "." INT (("e" | "E") ("+" | "-")? INT)? | "." INT (("e" | "E") ("+" | "-")? INT)? | INT (("e" | "E") ("+" | "-")?
	//	INT);
	public TerminalRule getFIXED_PT_LITERALRule() {
		return (tFIXED_PT_LITERAL != null) ? tFIXED_PT_LITERAL : (tFIXED_PT_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FIXED_PT_LITERAL"));
	} 

	//terminal FLOATING_PT_LITERAL:
	//	INT "." INT ("d" | "D") | INT ("d" | "D") | "." INT ("d" | "D");
	public TerminalRule getFLOATING_PT_LITERALRule() {
		return (tFLOATING_PT_LITERAL != null) ? tFLOATING_PT_LITERAL : (tFLOATING_PT_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "FLOATING_PT_LITERAL"));
	} 

	//terminal BOOLEAN_LITERAL:
	//	"TRUE" | "FALSE";
	public TerminalRule getBOOLEAN_LITERALRule() {
		return (tBOOLEAN_LITERAL != null) ? tBOOLEAN_LITERAL : (tBOOLEAN_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN_LITERAL"));
	} 

	//terminal HEX_LITERAL:
	//	"0" "x" ("0".."9" | "a".."f" | "A".."F")+;
	public TerminalRule getHEX_LITERALRule() {
		return (tHEX_LITERAL != null) ? tHEX_LITERAL : (tHEX_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "HEX_LITERAL"));
	} 

	//terminal ID:
	//	("a".."z" | "A".."Z" | "_" | "::") ("a".."z" | "A".."Z" | "_" | "0".."9" | "::")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"";
	public TerminalRule getSTRINGRule() {
		return (tSTRING != null) ? tSTRING : (tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "STRING"));
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
